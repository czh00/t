<!DOCTYPE html> <!-- 文件類型宣告為 HTML5 -->
<html lang="zh-Hant"> <!-- HTML 根元素，語言設定為繁體中文 -->
<head> <!-- 文件標頭，包含元數據和資源連結 -->
	<meta charset="UTF-8"> <!-- 設定字元編碼為 UTF-8 -->
	<meta content="width=device-width, initial-scale=1.0" name="viewport"> <!-- 設定視口，用於響應式設計，確保在不同裝置上正確顯示 -->
	<title>時間</title> <!-- 設定頁面標題 -->
	<script src="https://unpkg.com/lunar-javascript@1.7.3/lunar.js"></script> <!-- 引入 lunar-javascript 函式庫，用於農曆計算 -->
	<link href="https://fonts.cdnfonts.com/css/digital-dismay" rel="stylesheet"> <!-- 引入 Digital Dismay 字體，用於數位時鐘風格 -->
	<link rel="preconnect" href="https://fonts.googleapis.com"> <!-- 預先連接到 Google 字體伺服器以提高性能 -->
	<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&family=Inter:wght@400;700&display=swap" rel="stylesheet"> <!-- 引入 Noto Sans TC (思源黑體) 和 Inter 字體 -->
	<style> /* CSS 樣式開始 */
		:root { /* 定義 CSS 變數（自訂屬性），方便全域色彩管理 */
			--page-background-color: #000; --highlight-color: #ff5b3f; --hour-hand-color: #fff; --minute-hand-color: #fff; /* 頁面背景色、高亮色、時針色、分針色 */
			--second-hand-color: #ff5b3f; --tick-color: #fff; --number-color: #fff; --calendar-header-color: #ff5b3f; /* 秒針色、刻度色、數字色、日曆標頭色 */
			--calendar-weekday-color: #00ffff; --calendar-day-color: #fff; --calendar-lunar-color: #aaa; /* 日曆星期色、日期色、農曆色 */
		} /* CSS 變數定義結束 */
		*, *::before, *::after { box-sizing: border-box; } /* 通用選擇器，設定盒模型為 border-box，使寬高計算包含 padding 和 border */
		body { margin: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; min-height: 100vh; width: 100vw; position: relative; font-family: 'Noto Sans TC', sans-serif; background-color: var(--page-background-color); color: #fff; } /* body 元素樣式：移除邊距、隱藏滾動條、使用 flexbox 置中內容、填滿視窗、設定相對定位、預設字體、背景色和文字顏色 */
		.modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.8); } /* 彈出視窗（Modal）的基本樣式：預設隱藏、固定定位、高層級、覆蓋全螢幕、帶半透明黑色背景 */
		.modal.is-active { display: flex; justify-content: center; align-items: center; } /* 當彈出視窗啟用時的樣式：使用 flexbox 將內容置中 */
		#calendarModal, #weeklyCalendarModal, #yearlyCalendarModal { z-index: 110; } /* 為日曆相關的彈出視窗設定 z-index（堆疊順序） */
		#dateDetailsModal, #shichenDetailsModal, #weatherForecastModal, #hourlyWeatherModal, #moonPhaseModal, #zodiacModal { z-index: 120; } /* 為詳細資訊相關的彈出視窗設定更高的 z-index */
		#settingsModal { z-index: 130; } /* 為設定彈出視窗設定最高的 z-index */
		.modal-content { background-color: #333; margin: auto; padding: 20px; border: 1px solid #888; width: 90%; max-width: 600px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); color: #e0e0e0; text-align: center; display: flex; flex-direction: column; gap: 0px; max-height: 90vh; overflow-y: auto; position: relative; } /* 彈出視窗內容區域的樣式：深色背景、邊框、圓角、陰影、文字顏色、置中、flex 佈局、最大高度及滾動條 */
		.modal-header { display: flex; justify-content: space-between; align-items: center; padding: 0 10px; width: 100%; } /* 彈出視窗標頭的樣式：flex 佈局，兩端對齊 */
		.modal-header h2, .modal-header h3 { margin: 0; font-size: 1.5em; color: #00FF00; flex-grow: 1; text-align: center; } /* 彈出視窗標題樣式：移除邊距、字體大小、顏色、佔滿剩餘空間並置中 */
		.modal-header button { background: none; border: none; color: #00FF00; font-size: 2em; cursor: pointer; flex-shrink: 0; } /* 彈出視窗標頭按鈕樣式：透明背景、無邊框、顏色、大小、指標、不壓縮 */
		.close-icon { position: absolute; top: 8px; right: 12px; font-size: 1.25rem; font-weight: bold; color: #fff; cursor: pointer; line-height: 1; transition: color 0.3s; z-index: 10; user-select: none; } /* 關閉圖示的樣式：絕對定位於右上角、大小、顏色、指標、過渡效果、不可選取 */
		.close-icon:hover { color: var(--highlight-color); } /* 關閉圖示滑鼠懸停時的樣式：變為高亮色 */
		.action-button { background-color: #555; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 1.1em; margin-top: 0px; } /* 操作按鈕樣式：背景色、顏色、內距、無邊框、圓角、指標、字體大小 */
		.action-button:hover { background-color: #777; } /* 操作按鈕滑鼠懸停時的樣式：加深背景色 */
		.button-group { display: flex; justify-content: center; gap: 10px; margin-top: 20px; white-space: nowrap; flex-wrap: wrap; } /* 按鈕群組樣式：flex 佈局、置中、間距、不換行但允許換行 */
		.calendar-footer { display: flex; justify-content: center; gap: 10px; width: 100%; margin-top: 10px; } /* 日曆底部的樣式：flex 佈局、置中、間距 */
		.control-icon { position: fixed; bottom: 20px; width: 32px; height: 32px; cursor: pointer; z-index: 200; opacity: 0.5; transition: opacity 0.3s ease; } /* 控制圖示樣式：固定在右下角、大小、指標、高層級、半透明、過渡效果 */
		.control-icon svg { width: 100%; height: 100%; fill: #fff; } /* 控制圖示內的 SVG 樣式：填滿容器、白色填充 */
		.control-icon:hover { opacity: 1; } /* 控制圖示滑鼠懸停時的樣式：完全不透明 */
		#edit-mode-icon { right: 104px; } /* 編輯模式圖示的位置 */
		#settings-icon { right: 62px; } /* 設定圖示的位置 */
		#fullscreen-icon { right: 20px; } /* 全螢幕圖示的位置 */
		#settingsModal .modal-content { max-width: 850px; } /* 設定彈出視窗內容區域的最大寬度 */
		.setting-item { margin-bottom: 6px; display: flex; align-items: center; flex-wrap: nowrap; gap: 10px; transition: opacity 0.3s ease; } /* 設定項目的樣式：底部間距、flex 佈局、垂直居中、不換行、元素間距、透明度過渡 */
		.setting-item label:first-child { margin-right: auto; flex-shrink: 0;} /* 設定項目中第一個標籤的樣式：自動右邊距（推開右側元素）、不壓縮 */
		.setting-item.disabled { opacity: 0.5; pointer-events: none; } /* 禁用的設定項目樣式：半透明、禁用所有滑鼠事件 */
		.setting-item.disabled input, .setting-item.disabled select, .setting-item.disabled button { pointer-events: none; } /* 禁用設定項目內的輸入框、下拉選單和按鈕的滑鼠事件 */
		.switch { position: relative; display: inline-block; width: 48px; height: 27px; flex-shrink: 0; } /* 開關（switch）的容器樣式：相對定位、行內塊元素、固定寬高、不壓縮 */
		.switch input { opacity: 0; width: 0; height: 0; } /* 開關內的 checkbox 樣式：完全透明，隱藏起來 */
		.slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 27px; } /* 開關的滑塊背景樣式：絕對定位填滿容器、指標、背景色、過渡效果、圓角 */
		.slider:before { position: absolute; content: ""; height: 21px; width: 21px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; } /* 開關的圓形滑塊樣式：絕對定位、大小、位置、顏色、過渡效果、圓形 */
		input:checked + .slider { background-color: #00FF00; } /* 當 checkbox 被選中時，滑塊背景變色 */
		input:focus + .slider { box-shadow: 0 0 1px #00FF00; } /* 當 checkbox 獲得焦點時，滑塊背景顯示外陰影 */
		input:checked + .slider:before { transform: translateX(21px); } /* 當 checkbox 被選中時，圓形滑塊向右移動 */
		.setting-item input[type="color"] { width: 32px; height: 27px; border: none; padding: 0; background: none; cursor: pointer; flex-shrink: 0; } /* 顏色選擇器的樣式：大小、無邊框、無內距、透明背景、指標、不壓縮 */
		.setting-item input[type="text"] { background-color: #555; color: white; border: 1px solid #888; border-radius: 4px; padding: 5px; font-size: 0.9em; max-width: 100px; } /* 文字輸入框的樣式：背景色、文字顏色、邊框、圓角、內距、字體大小、最大寬度 */
		.setting-item button { background: none; border: none; cursor: pointer; padding: 0 5px; display: inline-flex; align-items: center; } /* 設定項目中按鈕的樣式：透明背景、無邊框、指標、內距、flex 佈局 */
		.setting-item button svg { width: 24px; height: 24px; stroke: white; } /* 設定項目中按鈕內 SVG 的樣式：大小、白色描邊 */
		.setting-controls { display: flex; align-items: center; gap: 5px; } /* 設定控制項的容器樣式：flex 佈局、垂直居中、間距 */
		.interval-selector-group { display: flex; align-items: center; gap: 2px; } /* 間隔選擇器群組的樣式 */
		.interval-select { background-color: #555; color: white; border: 1px solid #888; border-radius: 4px; padding: 5px; font-size: 0.9em; } /* 下拉選單的樣式 */
		.interval-select-label { color: #ccc; font-size: 0.9em; margin: 0; padding: 0 2px; } /* 下拉選單標籤的樣式 */
		.random-color-btn { background: #555; border: 1px solid #888; border-radius: 5px; cursor: pointer; padding: 0; font-size: 1.2em; line-height: 1; } /* 隨機顏色按鈕的樣式 */
		.random-color-btn:hover { background: #777; } /* 隨機顏色按鈕懸停樣式 */
		.location-input-group { display: flex; align-items: center; gap: 5px; flex-grow: 1; } /* 地點輸入群組的樣式：佔滿剩餘空間 */
		.location-controls-group { display: flex; align-items: center; gap: 5px; margin-left: auto; } /* 地點控制項群組的樣式：靠右對齊 */
		.settings-columns-container { display: flex; flex-wrap: wrap; gap: 0px; justify-content: space-around; width: 100%; } /* 設定區塊的容器樣式：flex 佈局、允許換行、環繞對齊 */
		.settings-column { flex: 1; min-width: 200px; padding: 10px; border: 1px solid #555; border-radius: 8px; background-color: #444; text-align: left; } /* 設定區塊中每一欄的樣式：彈性增長、最小寬度、內距、邊框、圓角、背景色 */
		.settings-column h3 { text-align: center; margin: 0; color: #00FF00; } /* 設定區塊欄目標題的樣式 */
		.calendar-content, .weekly-calendar-content { background-color: #2c2c2c; margin: auto; padding: 20px; border: 1px solid #888; border-radius: 10px; width: 95%; max-width: 900px; } /* 月曆和週曆內容區域的樣式 */
		.yearly-calendar-content { background-color: #2c2c2c; margin: auto; padding: 20px; border: 1px solid #888; border-radius: 10px; width: 95%; max-width: 1400px; } /* 年曆內容區域的樣式，寬度更大 */
		.calendar-weekdays, .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; } /* 星期標頭和日期網格的樣式：使用 grid 佈局，七欄等寬 */
		#calendarModal .calendar-grid { max-height: 65vh; overflow-y: auto; } /* 月曆彈出視窗中的日期網格：設定最大高度和垂直滾動條 */
		.calendar-weekdays div { font-weight: bold; padding-bottom: 5px; text-align: center; color: #aaa; } /* 星期標頭中每個元素的樣式 */
		.calendar-day { border-radius: 5px; padding: 5px; min-height: 80px; display: flex; flex-direction: column; justify-content: flex-start; align-items: center; font-size: 0.9em; border: 1px solid #555; cursor: pointer; transition: background-color: 0.3s; } /* 日期格子的樣式：圓角、內距、最小高度、flex 佈局、邊框、指標、過渡效果 */
		.calendar-day.is-today { border-color: #00FF00; box-shadow: 0 0 5px #00FF00; } /* 當天日期的樣式：高亮邊框和陰影 */
		.calendar-day .gregorian-day { font-size: 1.2em; font-weight: bold; } /* 日期格子中的國曆日期樣式 */
		.calendar-day .lunar-day { font-size: 0.8em; color: #ccc; white-space:nowrap; } /* 日期格子中的農曆日期樣式 */
		.calendar-day .event-indicator { font-size: 1em; padding: 1px 4px; border-radius: 3px; margin-top: 3px; display: block; text-align: center; width: 90%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin: 0; } /* 事件指示器的樣式：處理長文字溢出 */
		.event-indicator.holiday { background-color: #007bff; color: white; } /* 節假日事件指示器的樣式 */
		.event-indicator.jieqi { background-color: #28a745; color: white; } /* 節氣事件指示器的樣式 */
		.weekly-calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; } /* 週曆網格的樣式 */
		.weekly-calendar-day { border-radius: 8px; padding: 10px; min-height: 100px; display: flex; flex-direction: column; align-items: center; border: 1px solid #555; cursor: pointer; transition: background-color: 0.3s; } /* 週曆日期格子的樣式 */
		.weekly-calendar-day.is-today { border-color: #00FF00; box-shadow: 0 0 5px #00FF00; } /* 週曆中當天日期的樣式 */
		.weekly-day-header { font-weight: bold; font-size: 1.1em; margin-bottom: 5px; } /* 週曆日期標頭的樣式 */
		.weekly-gregorian-day { font-size: 1.5em; font-weight: bold; } /* 週曆國曆日期的樣式 */
		.weekly-lunar-day { font-size: 0.9em; color: #ccc; margin-top: 5px; } /* 週曆農曆日期的樣式 */
		.weekly-calendar-day .event-indicator { font-size: 0.8em; padding: 2px 5px; border-radius: 4px; margin-top: 5px; display: block; text-align: center; width: 90%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;} /* 週曆事件指示器的樣式 */
		.yearly-calendar-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; overflow-y: auto; padding: 10px; max-height: 75vh; } /* 年曆網格的樣式：自適應欄數、垂直滾動、最大高度 */
		.yearly-month-header { font-size: 1.2em; font-weight: bold; text-align: center; margin-bottom: 10px; color: #00FF00; cursor: pointer; } /* 年曆中月份標頭的樣式 */
		.yearly-weekdays, .yearly-day-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 3px; text-align: center; } /* 年曆中星期標頭和日期網格的樣式 */
		.yearly-weekdays div { font-size: 0.8em; color: #aaa; } /* 年曆中星期標頭的文字樣式 */
		.yearly-day { font-size: 0.9em; padding: 2px; border-radius: 3px; position: relative; cursor: pointer; transition: background-color: 0.3s; min-height: 24px; } /* 年曆中日期格子的樣式 */
		.yearly-day.is-today { background-color: #00FF00; color: #000; font-weight: bold; } /* 年曆中當天日期的樣式 */
		.yearly-indicators { position: absolute; bottom: 1px; left: 50%; transform: translateX(-50%); display: flex; gap: 2px; } /* 年曆中事件指示點的容器樣式 */
		.yearly-indicators .dot { width: 4px; height: 4px; border-radius: 50%; } /* 指示點的樣式 */
		.yearly-indicators .holiday { background-color: #007bff; } /* 節假日指示點的顏色 */
		.yearly-indicators .jieqi { background-color: #28a745; } /* 節氣指示點的顏色 */
		.details-content { max-width: 800px; text-align: left;} /* 詳細資訊內容的樣式 */
		.details-content p { margin-bottom: 10px; font-size: 1.2em; line-height: 1.6; } /* 詳細資訊段落的樣式 */
		.details-content strong { color: #FFD700; } /* 詳細資訊中強調文字的顏色 */
		.details-content .yi-ji-grid { display: grid; grid-template-columns: 40px 1fr; gap: 5px 10px; text-align: left;} /* 宜忌網格的樣式 */
		.details-content .yi-ji-grid strong { grid-column: 1; color: #FFD700; } /* 宜忌標題的樣式 */
		.details-content .yi-ji-grid span { grid-column: 2; } /* 宜忌內容的樣式 */
		.details-content .countdown-section { border-top: 1px solid #555; margin-top: 15px; padding-top: 15px; font-size: 1em; } /* 倒數計時區塊的樣式 */
		#weatherForecastModal .modal-content, #hourlyWeatherModal .modal-content { max-width: 1000px; } /* 天氣預報彈出視窗的樣式 */
		.weather-forecast-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(90px, 1fr)); gap: 10px; width: 100%; text-align: center; } /* 天氣預報網格的樣式：自適應欄數 */
		.forecast-day { background-color: #444; padding: 10px; border-radius: 8px; border: 1px solid #555; cursor: pointer; transition: background-color: 0.3s; } /* 預報日期的格子樣式 */
		.forecast-day:hover { background-color: #5e5e5e; } /* 預報日期格子懸停樣式 */
		.forecast-day p { margin: 2px 0; font-size: 1em; line-height: 1.4; } /* 預報日期格子內的段落樣式 */
		.forecast-day .day-name { font-weight: bold; color: #FFD700; } /* 預報日期的星期名稱樣式 */
		.forecast-day .weather-icon { margin: 5px 0; height: 2.5em; } /* 天氣圖示樣式 */
		.forecast-day .temp-high { color: #FFA07A; } /* 最高溫顏色 */
		.forecast-day .temp-low { color: #87CEFA; } /* 最低溫顏色 */
		.hourly-weather-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 10px; width: 100%; text-align: center; } /* 每小時天氣網格樣式 */
		.hourly-item { background-color: #444; padding: 10px; border-radius: 8px; border: 1px solid #555; } /* 每小時天氣項目樣式 */
		.hourly-item p { margin: 2px 0; font-size: 0.9em; line-height: 1.3; } /* 每小時天氣項目段落樣式 */
		.hourly-item .hour-time { font-weight: bold; color: #FFD700; } /* 小時時間樣式 */
		.hourly-item .weather-icon { margin: 4px 0; height: 2em; } /* 小時天氣圖示樣式 */
		.hourly-item.is-now { border-color: #00FF00; box-shadow: 0 0 8px #00FF00; } /* 當前小時的項目樣式 */
		#moonPhaseModal .modal-content { max-width: 500px; } /* 月相彈出視窗樣式 */
		#moonPhaseModalContent { display: flex; flex-direction: column; align-items: center; gap: 20px; text-align: center; } /* 月相彈出視窗內容樣式 */
		#moonPhaseDisplay { display: flex; flex-direction: column; align-items: center; gap: 15px; width: 100%; } /* 月相顯示區塊樣式 */
		#moonPhaseDisplay .moon-phase-icon-large { line-height: 1; } /* 大月相圖示樣式 */
		#moonPhaseDisplay p { font-size: 1.1em; line-height: 1.6; max-width: 400px; margin: 0; } /* 月相描述文字樣式 */
		.moon-calendar-container { width: 100%; max-width: 400px; margin-top: 15px; border-top: 1px solid #555; padding-top: 15px; } /* 月相日曆容器樣式 */
		#moonCalendarGrid .calendar-day { min-height: 65px; padding: 2px; font-size: 0.8em; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 2px; } /* 月相日曆格子樣式 */
		#moonCalendarGrid .calendar-day .gregorian-day { font-size: 1.1em; } /* 月相日曆國曆日期樣式 */
		#moonCalendarGrid .moon-phase-icon-small svg, #moonCalendarGrid .moon-phase-icon-small img { width: 24px; height: 24px; } /* 小月相圖示樣式 */
		#moonCalendarGrid .calendar-day.is-selected { border-color: #FFD700; box-shadow: 0 0 8px #FFD700; background-color: #5a5a5a; } /* 月相日曆中選定日期的樣式 */
		#moonCalendarGrid .lunar-day { font-size: 0.75em; color: #ccc; } /* 月相日曆農曆日期樣式 */
		#zodiacModal .modal-content { max-width: 800px; } /* 生肖彈出視窗樣式 */
		.zodiac-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 15px; width: 100%; text-align: center; } /* 生肖網格樣式 */
		.zodiac-item { background-color: #444; padding: 10px; border-radius: 8px; border: 1px solid #555; } /* 生肖項目樣式 */
		.zodiac-item .zodiac-icon { height: 4em; margin-bottom: 5px; } /* 生肖圖示樣式 */
		.zodiac-item p { margin: 0; font-weight: bold; } /* 生肖名稱樣式 */
		#master-layout { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); transition: transform 1s ease-in-out; will-change: transform; z-index: 2; } /* 主佈局容器樣式：絕對定位置中、過渡效果 */
		.widget-wrapper { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); transition: transform 1s ease-in-out; will-change: transform; z-index: 10; display: inline-flex; justify-content: center; align-items: center; } /* 小工具包裝器樣式：絕對定位置中、過渡效果 */
		body.edit-mode .widget-wrapper { cursor: grab; } /* 當 body 元素有 'edit-mode' 類別時，小工具包裝器的樣式（游標變為抓取手勢） */
		#dateTimeDisplay { font-family: 'Digital Dismay', 'Noto Sans TC', sans-serif; font-weight: bold; text-align: center; padding: 10px; text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5); cursor: default; z-index: 10; } /* 日期時間顯示區塊的樣式：數位字體、文字陰影 */
		.time-text { font-size: 42vw; font-weight: normal; margin-bottom: -7vw; position: relative; display: inline-flex; align-items: baseline; gap: 0; white-space: nowrap; padding-right: 1vw; line-height: 0.75; } /* 時間文字樣式：超大字體、相對視窗寬度、行高調整 */
		.time-colon { line-height: 1; display: inline-flex; align-items: center; justify-content: center; } /* 時間冒號的容器樣式 */
		.time-colon svg { fill: currentColor; position: relative; top: 0.05em; height: 0.6em; } /* 時間冒號 SVG 的樣式 */
		.time-seconds { font-size: 8vw; font-weight: normal; position: absolute; right: 0vw; bottom: 1vw; text-align: right; width: 6vw; } /* 秒數文字樣式：絕對定位於右下角 */
		.time-ampm { font-size: 4.2vw; font-weight: bold; position: absolute; top: 1vw; right: 0vw; text-align: right; width: 8vw; } /* AM/PM 文字樣式：絕對定位於右上角 */
		#hoursDisplay, #minutesDisplay, #secondsDisplay { position: relative; } /* 時、分、秒顯示容器：相對定位 */
		#hoursDisplay::before, #minutesDisplay::before, #secondsDisplay::before { /* 使用 ::before 偽元素為時、分、秒顯示 '88' 作為背景佔位符，製造數位螢幕效果 */
			content: '88'; /* 偽元素的內容 */
			position: absolute; /* 絕對定位 */
			top: 0; left: 0; /* 位置與父元素重合 */
			width: 100%; height: 100%; /* 大小與父元素相同 */
			color: rgba(255, 255, 255, 0.1); /* 半透明顏色 */
			z-index: -1; /* 位於父元素下方 */
			display: flex; /* 使用 flex 佈局 */
			justify-content: center; /* 水平置中 */
			align-items: baseline; /* 基線對齊 */
		} /* 偽元素樣式結束 */
		.gregorian-date-text, .lunar-and-jieqi-line { font-family: 'Noto Sans TC', 'Inter', sans-serif; display: flex; justify-content: center; align-items: baseline; white-space: nowrap; cursor: default; position: relative; z-index: 1; width: 92vw; font-weight: 1000; padding: 0.1vw 0; line-height: 0.9; } /* 國曆和農曆行的通用樣式 */
		.gregorian-date-text { font-size: 6.5vw; } /* 國曆日期文字大小 */
		.lunar-and-jieqi-line { font-size: 6.25vw; } /* 農曆和節氣行文字大小 */
		.gregorian-date-parts, .lunar-date-static-text { flex-shrink: 0; } /* 日期文字部分：不壓縮 */
		.gregorian-date-parts span, .lunar-date-static-text span, .lunar-date-static-text .lunar-month-target-group { cursor: pointer; } /* 日期文字中的可點擊部分：指標變為手形 */
		.lunar-date-static-text span:last-child { margin-right: 0; } /* 農曆文字最後一個 span：移除右邊距 */
		.moon-phase-icon-target { margin-left: 0; } /* 月相圖示目標：移除左邊距 */
		.weather-marquee-container, .jieqi-holiday-marquee-container { flex-grow: 1; overflow: hidden; position: relative; text-align: left; min-width: 0; cursor: pointer; align-self: stretch; display: flex; align-items: center; } /* 跑馬燈容器樣式：佔滿剩餘空間、隱藏溢出內容、可點擊 */
		.weather-marquee-inner, .jieqi-holiday-marquee-inner { display: flex; flex-wrap: nowrap; width: fit-content; will-change: transform; } /* 跑馬燈內部容器樣式：不換行、寬度由內容決定、優化 transform 動畫 */
		.weather-marquee-content, .weather-marquee-content-duplicate, .jieqi-holiday-marquee-content, .jieqi-holiday-marquee-content-duplicate { display: inline-flex; align-items: baseline; white-space: nowrap; flex-shrink: 0; } /* 跑馬燈內容樣式（包含複製份，用於無縫滾動） */
		.weather-marquee-container.scrolling .weather-marquee-inner, .jieqi-holiday-marquee-container.scrolling .jieqi-holiday-marquee-inner { animation-name: marquee; animation-timing-function: linear; animation-iteration-count: infinite; } /* 當容器有 'scrolling' 類別時，套用跑馬燈動畫 */
		@keyframes marquee { from { transform: translateX(0); } to { transform: translateX(-50%); } } /* 定義名為 marquee 的 CSS 動畫，從原位移動到自身寬度一半的位置，實現無縫滾動 */
		#background-scanline-overlay, #text-scanline-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background-color: transparent; display: none; } /* 掃描線覆蓋層的通用樣式：固定定位、覆蓋全螢幕、不影響滑鼠事件、預設隱藏 */
		#background-scanline-overlay { z-index: -1; } /* 背景掃描線：位於最底層 */
		#text-scanline-overlay { z-index: 50; } /* 文字掃描線：位於文字上方 */
		#background-scanline-overlay.active.pattern-a { display: block; background-image: repeating-linear-gradient(to bottom, transparent, transparent 2px, rgba(255,255,255,0.1) 2px, rgba(255,255,255,0.1) 4px); } /* 背景掃描線樣式 A */
		#background-scanline-overlay.active.pattern-b { display: block; background-image: repeating-linear-gradient(to bottom, rgba(255,255,255,0.1) 0, rgba(255,255,255,0.1) 2px, transparent 2px, transparent 4px); } /* 背景掃描線樣式 B */
		#text-scanline-overlay.active.pattern-a { display: block; background-image: repeating-linear-gradient(to bottom, transparent, transparent 2px, var(--page-background-color) 2px, var(--page-background-color) 4px); } /* 文字掃描線樣式 A (使用背景色遮蓋文字) */
		#text-scanline-overlay.active.pattern-b { display: block; background-image: repeating-linear-gradient(to bottom, var(--page-background-color) 0, var(--page-background-color) 2px, transparent 2px, transparent 4px); } /* 文字掃描線樣式 B */
		.weather-svg-icon { display: inline-block; vertical-align: middle; transform: translateY(-10%); } /* 天氣 SVG 圖示的樣式：垂直對齊、微調位置 */
		.zodiac-svg-icon { display: inline-block; vertical-align: middle; transform: translateY(-15%); } /* 生肖 SVG 圖示的樣式 */
		.clock-container { width: clamp(250px, 40vmin, 500px); aspect-ratio: 1 / 1; position: relative; border-radius: 50%; display: flex; justify-content: center; align-items: center; background-color: transparent; box-shadow: 0 0 0 0px var(--tick-color); flex-shrink: 0; } /* 指針時鐘容器樣式：響應式寬度、正方形比例、圓形、flex 置中 */
		.clock-center-dot { position: absolute; width: 15px; height: 15px; background-color: var(--tick-color); border-radius: 50%; z-index: 11; cursor: pointer; transition: transform 0.2s ease; } /* 時鐘中心點的樣式 */
		.clock-center-dot:hover { transform: scale(1.1); } /* 時鐘中心點懸停時放大 */
		.hand { position: absolute; height: 100%; width: 100%; z-index: 10; } /* 指針的容器樣式 */
		.hour-hand i { position: absolute; top: 25%; left: 50%; width: 10px; height: 25%; background-color: var(--hour-hand-color); transform: translateX(-50%); border-radius: 2px; } /* 時針的樣式 */
		.minute-hand i { position: absolute; top: 15%; left: 50%; width: 6px; height: 35%; background-color: var(--minute-hand-color); transform: translateX(-50%); border-radius: 2px; } /* 分針的樣式 */
		.second-hand i { position: absolute; top: 10%; left: 50%; width: 2px; height: 40%; background-color: var(--second-hand-color); transform: translateX(-50%); border-radius: 1px; } /* 秒針的樣式 */
		.tick-wrapper { position: absolute; top: 0; left: 0; width: 100%; height: 100%; } /* 刻度包裝器樣式 */
		.tick { position: absolute; background: var(--tick-color); left: 50%; transform: translateX(-50%); } /* 刻度的通用樣式 */
		.tick-hour { height: 12px; width: 3px; top: 0; } /* 小時刻度的樣式 */
		.tick-minute { height: 6px; width: 1px; top: 0; opacity: 0.7; } /* 分鐘刻度的樣式 */
		.number { position: absolute; top: 25px; left: 50%; transform: translateX(-50%); color: var(--number-color); font-family: 'Noto Sans TC', sans-serif; font-size: clamp(0.8rem, 2.2vw, 1.4rem); font-weight: 700; } /* 時鐘數字的容器樣式 */
		.number div { transform: rotate(calc(-1 * var(--rotation))); } /* 將數字反向旋轉，使其正對使用者，抵銷父元素的旋轉 */
		.calendar-container { width: clamp(280px, 85vw, 600px); text-align: center; z-index: 10; display: flex; flex-direction: column; flex-shrink: 0; position: relative; padding: 10px; background-color: rgba(30, 30, 30, 0.5); border-radius: 10px; overflow: hidden; } /* 類比時鐘旁的日曆容器樣式 */
		#analog-calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; background-color: transparent; width: 100%; z-index: 1; } /* 類比時鐘日曆的網格樣式 */
		#analog-calendar-grid .weekday-header { font-weight: bold; color: var(--calendar-weekday-color); padding-bottom: 5px; text-align: center; } /* 類比時鐘日曆的星期標頭樣式 */
		.calendar-container .calendar-day { border-color: transparent; min-height: 4vh; padding: 0.1em; display: flex; flex-direction: row; justify-content: center; align-items: center; position: relative; } /* 類比時鐘日曆的日期格子樣式 */
		.calendar-container .calendar-day.is-today { background-color: transparent !important; border: 1px solid var(--highlight-color); } /* 類比時鐘日曆中當天的樣式 */
		.analog-day-main { display: flex; flex-direction: column; justify-content: center; align-items: center; flex-grow: 1; } /* 類比日曆中日期的主要部分 */
		.analog-day-events { display: flex; flex-direction: column; justify-content: space-around; align-items: center; writing-mode: vertical-rl; text-orientation: mixed; white-space: nowrap; font-size: clamp(0.65rem, 1.4vw, 0.8rem); margin-left: 3px; min-width: 1.5em; text-align: center; } /* 類比日曆中事件顯示區塊：垂直排列文字 */
		.analog-day-events:empty { visibility: hidden; } /* 如果沒有事件，則隱藏事件區塊 */
		.analog-day-events .event-indicator { padding: 2px 0; margin: 0; border-radius: 3px; } /* 類比日曆中事件指示器的樣式 */
		.calendar-container .calendar-day .gregorian-day { font-size: clamp(0.9rem, 1.5vw, 1.2rem); font-weight: bold; color: var(--calendar-day-color); } /* 類比日曆中國曆日期的樣式 */
		.calendar-container .calendar-day .lunar-day { font-size: clamp(0.7rem, 1vw, 0.9rem); color: var(--calendar-lunar-color); } /* 類比日曆中農曆日期的樣式 */
		.calendar-bg-month, .analog-calendar-bg-month { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-weight: 900; color: rgba(255, 255, 255, 0.12); z-index: 0; pointer-events: none; font-family: 'Noto Sans TC', 'Inter', sans-serif; line-height: 1; transition: color 0.4s ease; } /* 日曆背景月份數字的通用樣式：絕對定位置中、超大字體、半透明、不影響滑鼠 */
		.calendar-content .calendar-bg-month { font-size: 20rem; top: 42%; } /* 彈出視窗月曆的背景月份樣式 */
		.yearly-month-container .calendar-bg-month { font-size: 10rem; top: 52%; } /* 年曆中月份的背景月份樣式 */
		.analog-calendar-bg-month { font-size: 10rem; } /* 類比時鐘旁日曆的背景月份樣式 */
		.calendar-content, .yearly-calendar-content { position: relative; overflow: hidden; } /* 為日曆內容設定相對定位和隱藏溢出，以容納背景月份 */
		.yearly-month-container { position: relative; overflow: hidden; background-color: transparent; border: 1px solid #555; } /* 年曆中每個月份容器的樣式 */
		.calendar-day, .weekly-calendar-day { background-color: transparent !important; z-index: 1; } /* 確保日期格子的背景透明，且層級高於背景月份 */
		.calendar-day.other-month { color: #777; } /* 非當前月份的日期樣式：灰色文字 */
		.calendar-day:hover, .weekly-calendar-day:hover, .calendar-container .calendar-day:hover { background-color: rgba(94, 94, 94, 0.5) !important; } /* 日期格子懸停時的背景色 */
		.calendar-day.other-month:hover { background-color: rgba(74, 74, 74, 0.5) !important; } /* 非當前月份日期懸停時的背景色 */
		.yearly-day:hover { background-color: rgba(85, 85, 85, 0.7); } /* 年曆日期懸停時的背景色 */
		.edit-controls-wrapper { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 2px dashed rgba(0, 255, 255, 0.5); display: none; pointer-events: none; z-index: 99; } /* 編輯模式控制項的包裝器樣式：虛線邊框、預設隱藏 */
		body.edit-mode .edit-controls-wrapper { display: block; } /* 編輯模式下顯示控制項包裝器 */
		.move-handle { position: absolute; background-color: rgba(0, 255, 255, 0.8); border: 1px solid #fff; border-radius: 50%; pointer-events: auto; z-index: 100; box-shadow: 0 0 10px rgba(0, 255, 255, 0.7); width: 40px; height: 40px; top: 50%; left: 50%; cursor: move; } /* 移動控制柄的樣式：圓形、中心十字 */
		.move-handle::before, .move-handle::after { content: ''; position: absolute; background-color: #000; } /* 移動控制柄的十字線（偽元素） */
		.move-handle::before { width: 60%; height: 10%; top: 45%; left: 20%; } /* 移動控制柄的橫線 */
		.move-handle::after { width: 10%; height: 60%; top: 20%; left: 45%; } /* 移動控制柄的豎線 */
		.resize-handle-x { position: absolute; top: 50%; right: -10px; transform: translateY(-50%); width: 10px; height: 40px; background-color: rgba(0, 255, 255, 0.8); border: 1px solid #fff; border-radius: 5px; cursor: ew-resize; pointer-events: auto; z-index: 101; display: none; } /* 水平縮放控制柄的樣式 */
		body.edit-mode .resize-handle-x { display: block; } /* 編輯模式下顯示水平縮放控制柄 */
		#edit-mode-grid { /* 編輯模式下的網格覆蓋層樣式 */
			display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; /* 預設隱藏，固定定位覆蓋全螢幕 */
			background-image: /* 使用兩個線性漸層來繪製網格線 */
				linear-gradient(to bottom, transparent 24px, rgba(0, 255, 255, 0.2) 24px, rgba(0, 255, 255, 0.2) 25px, transparent 25px), /* 水平線 */
				linear-gradient(to right, transparent 24px, rgba(0, 255, 255, 0.2) 24px, rgba(0, 255, 255, 0.2) 25px, transparent 25px); /* 垂直線 */
			background-size: 50px 50px; background-position: center center; /* 設定網格大小和位置 */
			z-index: 90; pointer-events: none; /* 較低的層級，不影響滑鼠事件 */
		} /* 編輯模式網格樣式結束 */
		#edit-mode-grid::before, #edit-mode-grid::after { content: ''; position: absolute; background-color: rgba(255, 0, 255, 0.5); z-index: 91; } /* 編輯模式網格的中心十字線（偽元素） */
		#edit-mode-grid::before { top: 0; left: 50%; width: 1px; height: 100%; transform: translateX(-50%); } /* 中心垂直線 */
		#edit-mode-grid::after { top: 50%; left: 0; width: 100%; height: 1px; transform: translateY(-50%); } /* 中心水平線 */
		body.edit-mode #edit-mode-grid { display: block; } /* 編輯模式下顯示網格 */
	</style> <!-- CSS 樣式結束 -->
</head> <!-- 文件標頭結束 -->
<body> <!-- 頁面可見內容的開始 -->
	<div id="edit-mode-grid"></div> <!-- 用於編輯模式下的網格覆蓋層 -->
	<div id="background-scanline-overlay"></div> <!-- 用於顯示背景掃描線效果的覆蓋層 -->
	<div id="text-scanline-overlay"></div> <!-- 用於顯示文字掃描線效果的覆蓋層 -->
	<div id="master-layout"> <!-- 所有可見小工具的主佈局容器 -->
		<div id="digital-widget" class="widget-wrapper"> <!-- 數位時鐘小工具的包裝器 -->
			<div id="dateTimeDisplay"> <!-- 日期和時間的顯示容器 -->
				<div class="time-text" id="timeTextContainer"> <!-- 時間文字的容器 -->
					<span id="hoursDisplay"></span> <!-- 用於顯示小時 -->
					<span id="colonDisplay" class="time-colon"> <!-- 用於顯示冒號 -->
						<svg viewbox="0 0 60 250"><rect x="0" y="10" width="40" height="40" rx="10" ry="10"></rect><rect x="0" y="130" width="40" height="40" rx="10" ry="10"></rect></svg> <!-- 冒號的 SVG 圖形 -->
					</span> <!-- 冒號顯示結束 -->
					<span id="minutesDisplay"></span> <!-- 用於顯示分鐘 -->
					<span class="time-seconds" id="secondsDisplay"></span> <!-- 用於顯示秒數 -->
					<span class="time-ampm" id="amPmDisplay"></span> <!-- 用於顯示 AM/PM -->
				</div> <!-- 時間文字容器結束 -->
			</div> <!-- 日期時間顯示容器結束 -->
			<div class="edit-controls-wrapper"><div class="move-handle"></div></div> <!-- 編輯模式下的控制項（移動手柄） -->
		</div> <!-- 數位時鐘小工具結束 -->
		<div id="gregorian-date-widget" class="widget-wrapper"> <!-- 國曆日期小工具的包裝器 -->
			<div class="gregorian-date-text" id="gregorianDateDisplay"> <!-- 國曆日期的顯示容器 -->
				<span class="gregorian-date-parts" id="gregorianDateParts"></span> <!-- 顯示年、月、日、星期的部分 -->
				<div class="weather-marquee-container" id="weatherMarqueeContainer"> <!-- 天氣資訊跑馬燈的容器 -->
					<div class="weather-marquee-inner" id="weatherMarqueeInner"><span class="weather-marquee-content"></span><span class="weather-marquee-content-duplicate"></span></div> <!-- 跑馬燈內部內容（包含複製份以實現無縫滾動） -->
				</div> <!-- 天氣跑馬燈容器結束 -->
			</div> <!-- 國曆日期顯示容器結束 -->
			<div class="edit-controls-wrapper"><div class="move-handle"></div><div class="resize-handle-x"></div></div> <!-- 編輯模式下的控制項（移動和縮放手柄） -->
		</div> <!-- 國曆日期小工具結束 -->
		<div id="lunar-date-widget" class="widget-wrapper"> <!-- 農曆日期小工具的包裝器 -->
			<div class="lunar-and-jieqi-line" id="lunarAndJieqiLine"> <!-- 農曆和節氣行的顯示容器 -->
				<span class="lunar-date-static-text" id="lunarDateDisplay"></span> <!-- 顯示農曆日期的部分 -->
				<div class="jieqi-holiday-marquee-container" id="jieqiHolidayMarqueeContainer"> <!-- 節氣和節日跑馬燈的容器 -->
					<div class="jieqi-holiday-marquee-inner" id="jieqiHolidayMarqueeInner"><span class="jieqi-holiday-marquee-content"></span><span class="jieqi-holiday-marquee-content-duplicate"></span></div> <!-- 跑馬燈內部內容 -->
				</div> <!-- 節氣節日跑馬燈容器結束 -->
			</div> <!-- 農曆和節氣行容器結束 -->
			<div class="edit-controls-wrapper"><div class="move-handle"></div><div class="resize-handle-x"></div></div> <!-- 編輯模式下的控制項 -->
		</div> <!-- 農曆日期小工具結束 -->
		<div id="analog-clock-widget" class="widget-wrapper" style="display: none;"> <!-- 指針時鐘小工具的包裝器，預設隱藏 -->
			<div class="clock-container"> <!-- 時鐘本身的容器 -->
				<div class="hand hour-hand"><i></i></div><div class="hand minute-hand"><i></i></div><div class="hand second-hand"><i></i></div> <!-- 時、分、秒針 -->
				<div class="clock-center-dot" id="clockCenterDot" title="查看時辰宜忌"></div> <!-- 時鐘中心點，可點擊 -->
				<div id="ticks-container"></div> <!-- 用於動態生成時鐘刻度的容器 -->
			</div> <!-- 時鐘容器結束 -->
			<div class="edit-controls-wrapper"><div class="move-handle"></div></div> <!-- 編輯模式下的控制項 -->
		</div> <!-- 指針時鐘小工具結束 -->
		<div id="analog-calendar-widget" class="widget-wrapper" style="display: none;"> <!-- 類比風格月曆小工具的包裝器，預設隱藏 -->
			<div class="calendar-container"> <!-- 月曆本身的容器 -->
				<div class="analog-calendar-bg-month"></div> <!-- 月曆背景的巨大月份數字 -->
				<div id="analog-calendar-grid"></div> <!-- 月曆的日期網格 -->
			</div> <!-- 月曆容器結束 -->
			<div class="edit-controls-wrapper"><div class="move-handle"></div></div> <!-- 編輯模式下的控制項 -->
		</div> <!-- 類比月曆小工具結束 -->
	</div> <!-- 主佈局容器結束 -->
	<div class="modal" id="settingsModal"> <!-- 設定彈出視窗 -->
		<div class="modal-content"> <!-- 彈出視窗內容 -->
			<span class="close-icon">&times;</span> <!-- 關閉按鈕 -->
			<div class="modal-header"><h2>顯示設定</h2></div> <!-- 彈出視窗標頭 -->
			<div class="settings-columns-container"> <!-- 設定項目的多欄容器 -->
				<div class="settings-column"> <!-- 第一欄設定 -->
					<h3>數位時間</h3> <!-- 區塊標題 -->
					<div class="setting-item"><label for="showDigitalTime">數位時間</label><div class="setting-controls"><label class="switch"><input id="showDigitalTime" type="checkbox"><span class="slider"></span></label></div></div> <!-- 顯示/隱藏數位時間的開關 -->
					<div class="setting-item"><label for="hourColor">時</label><div class="setting-controls"><input id="hourColor" type="color"><button class="random-color-btn" data-target="hourColor" title="隨機顏色">🎨</button></div></div> <!-- 小時顏色選擇器 -->
					<div class="setting-item"><label for="minuteColor">分</label><div class="setting-controls"><input id="minuteColor" type="color"><button class="random-color-btn" data-target="minuteColor" title="隨機顏色">🎨</button></div></div> <!-- 分鐘顏色選擇器 -->
					<div class="setting-item"><label for="secondColor">秒</label><div class="setting-controls"><input id="secondColor" type="color"><button class="random-color-btn" data-target="secondColor" title="隨機顏色">🎨</button></div></div> <!-- 秒數顏色選擇器 -->
					<div class="setting-item"><label for="colonColor">冒號</label><div class="setting-controls"><input id="colonColor" type="color"><button class="random-color-btn" data-target="colonColor" title="隨機顏色">🎨</button></div></div> <!-- 冒號顏色選擇器 -->
					<div class="setting-item"><label for="showAmPm">12/24小時</label><div class="setting-controls"><label class="switch" title="切換12/24小時格式"><input id="showAmPm" type="checkbox"><span class="slider"></span></label><input id="amPmColor" type="color"><button class="random-color-btn" data-target="amPmColor" title="隨機顏色">🎨</button></div></div> <!-- 12/24 小時制切換及顏色選擇 -->
					<hr> <!-- 分隔線 -->
					<h3>公曆</h3> <!-- 區塊標題 -->
					<div class="setting-item"><label for="showGregorianDate">公曆</label><div class="setting-controls"><label class="switch"><input id="showGregorianDate" type="checkbox"><span class="slider"></span></label></div></div> <!-- 顯示/隱藏國曆日期的開關 -->
					<div class="setting-item"><label for="showGregorianYear">年</label><div class="setting-controls"><label class="switch"><input id="showGregorianYear" type="checkbox"><span class="slider"></span></label><input id="gregorianYearColor" type="color"><button class="random-color-btn" data-target="gregorianYearColor" title="隨機顏色">🎨</button></div></div> <!-- 顯示/隱藏國曆年份及顏色選擇 -->
					<div class="setting-item"><label for="showGregorianMonth">月</label><div class="setting-controls"><label class="switch"><input id="showGregorianMonth" type="checkbox"><span class="slider"></span></label><input id="gregorianMonthColor" type="color"><button class="random-color-btn" data-target="gregorianMonthColor" title="隨機顏色">🎨</button></div></div> <!-- 顯示/隱藏國曆月份及顏色選擇 -->
					<div class="setting-item"><label for="showGregorianDay">日</label><div class="setting-controls"><label class="switch"><input id="showGregorianDay" type="checkbox"><span class="slider"></span></label><input id="gregorianDayColor" type="color"><button class="random-color-btn" data-target="gregorianDayColor" title="隨機顏色">🎨</button></div></div> <!-- 顯示/隱藏國曆日期及顏色選擇 -->
					<div class="setting-item"><label for="showGregorianWeekday">周</label><div class="setting-controls"><label class="switch"><input id="showGregorianWeekday" type="checkbox"><span class="slider"></span></label><input id="gregorianWeekdayColor" type="color"><button class="random-color-btn" data-target="gregorianWeekdayColor" title="隨機顏色">🎨</button></div></div> <!-- 顯示/隱藏星期及顏色選擇 -->
					<div class="setting-item"><label for="showWeather">天氣資訊</label><div class="setting-controls"><label class="switch"><input id="showWeather" type="checkbox"><span class="slider"></span></label><input id="weatherColor" type="color"><button class="random-color-btn" data-target="weatherColor" title="隨機顏色">🎨</button></div></div> <!-- 顯示/隱藏天氣資訊及顏色選擇 -->
					<div class="setting-item"><label for="showWeatherLocation">天氣地區</label><div class="setting-controls"><label class="switch"><input id="showWeatherLocation" type="checkbox"><span class="slider"></span></label><input id="weatherLocationColor" type="color"><button class="random-color-btn" data-target="weatherLocationColor" title="隨機顏色">🎨</button></div></div> <!-- 顯示/隱藏天氣地區及顏色選擇 -->
				</div> <!-- 第一欄設定結束 -->
				<div class="settings-column"> <!-- 第二欄設定 -->
					<h3>類比時鐘</h3> <!-- 區塊標題 -->
					<div class="setting-item"><label for="showAnalogClock">類比時鐘</label><div class="setting-controls"><label class="switch"><input id="showAnalogClock" type="checkbox"><span class="slider"></span></label></div></div> <!-- 顯示/隱藏指針時鐘的開關 -->
					<div class="setting-item"><label for="hourHandColor">時</label><div class="setting-controls"><input id="hourHandColor" type="color"><button class="random-color-btn" data-target="hourHandColor" title="隨機顏色">🎨</button></div></div> <!-- 時針顏色選擇器 -->
					<div class="setting-item"><label for="minuteHandColor">分</label><div class="setting-controls"><input id="minuteHandColor" type="color"><button class="random-color-btn" data-target="minuteHandColor" title="隨機顏色">🎨</button></div></div> <!-- 分針顏色選擇器 -->
					<div class="setting-item"><label for="secondHandColor">秒</label><div class="setting-controls"><input id="secondHandColor" type="color"><button class="random-color-btn" data-target="secondHandColor" title="隨機顏色">🎨</button></div></div> <!-- 秒針顏色選擇器 -->
					<div class="setting-item"><label for="tickColor">刻度</label><div class="setting-controls"><input id="tickColor" type="color"><button class="random-color-btn" data-target="tickColor" title="隨機顏色">🎨</button></div></div> <!-- 刻度顏色選擇器 -->
					<div class="setting-item"><label for="numberColor">時間數字</label><div class="setting-controls"><input id="numberColor" type="color"><button class="random-color-btn" data-target="numberColor" title="隨機顏色">🎨</button></div></div> <!-- 時鐘數字顏色選擇器 -->
					<hr> <!-- 分隔線 -->
					<h3>農曆</h3> <!-- 區塊標題 -->
					<div class="setting-item"><label for="showLunarDate">農曆</label><div class="setting-controls"><label class="switch"><input id="showLunarDate" type="checkbox"><span class="slider"></span></label></div></div> <!-- 顯示/隱藏農曆日期的開關 -->
					<div class="setting-item"><label for="showMinguoYear">年</label><div class="setting-controls"><label class="switch"><input id="showMinguoYear" type="checkbox"><span class="slider"></span></label><input id="minguoYearColor" type="color"><button class="random-color-btn" data-target="minguoYearColor" title="隨機顏色">🎨</button></div></div> <!-- 顯示/隱藏天干地支年及顏色選擇 -->
					<div class="setting-item"><label for="showLunarMonth">月</label><div class="setting-controls"><label class="switch"><input id="showLunarMonth" type="checkbox"><span class="slider"></span></label><input id="lunarMonthColor" type="color"><button class="random-color-btn" data-target="lunarMonthColor" title="隨機顏色">🎨</button></div></div> <!-- 顯示/隱藏農曆月份及顏色選擇 -->
					<div class="setting-item"><label for="showLunarDay">日</label><div class="setting-controls"><label class="switch"><input id="showLunarDay" type="checkbox"><span class="slider"></span></label><input id="lunarDayColor" type="color"><button class="random-color-btn" data-target="lunarDayColor" title="隨機顏色">🎨</button></div></div> <!-- 顯示/隱藏農曆日期及顏色選擇 -->
					<div class="setting-item"><label for="showLunarShiChen">時辰</label><div class="setting-controls"><label class="switch"><input id="showLunarShiChen" type="checkbox"><span class="slider"></span></label><input id="lunarShiChenColor" type="color"><button class="random-color-btn" data-target="lunarShiChenColor" title="隨機顏色">🎨</button></div></div> <!-- 顯示/隱藏時辰及顏色選擇 -->
					<div class="setting-item"><label for="showJieqi">節氣</label><div class="setting-controls"><label class="switch"><input id="showJieqi" type="checkbox"><span class="slider"></span></label><input id="jieqiColor" type="color"><button class="random-color-btn" data-target="jieqiColor" title="隨機顏色">🎨</button></div></div> <!-- 顯示/隱藏節氣及顏色選擇 -->
					<div class="setting-item"><label for="showHolidays">節日</label><div class="setting-controls"><label class="switch"><input id="showHolidays" type="checkbox"><span class="slider"></span></label><input id="holidayColor" type="color"><button class="random-color-btn" data-target="holidayColor" title="隨機顏色">🎨</button></div></div> <!-- 顯示/隱藏節日及顏色選擇 -->
				</div> <!-- 第二欄設定結束 -->
			</div> <!-- 設定項目多欄容器結束 -->
			<div class="settings-columns-container"> <!-- 另一組設定項目的多欄容器 -->
				<div class="settings-column"> <!-- 第三欄設定 -->
					<h3>月曆</h3> <!-- 區塊標題 -->
					<div class="setting-item"><label for="showAnalogCalendar">月曆</label><div class="setting-controls"><label class="switch"><input id="showAnalogCalendar" type="checkbox"><span class="slider"></span></label></div></div> <!-- 顯示/隱藏類比月曆的開關 -->
					<div class="setting-item"><label for="calendarHeaderColor">月</label><div class="setting-controls"><input id="calendarHeaderColor" type="color"><button class="random-color-btn" data-target="calendarHeaderColor" title="隨機顏色">🎨</button></div></div> <!-- 月曆標頭顏色選擇器 -->
					<div class="setting-item"><label for="calendarWeekdayColor">周</label><div class="setting-controls"><input id="calendarWeekdayColor" type="color"><button class="random-color-btn" data-target="calendarWeekdayColor" title="隨機顏色">🎨</button></div></div> <!-- 月曆星期顏色選擇器 -->
					<div class="setting-item"><label for="calendarDayColor">日</label><div class="setting-controls"><input id="calendarDayColor" type="color"><button class="random-color-btn" data-target="calendarDayColor" title="隨機顏色">🎨</button></div></div> <!-- 月曆日期顏色選擇器 -->
					<div class="setting-item"><label for="calendarLunarColor">農曆</label><div class="setting-controls"><input id="calendarLunarColor" type="color"><button class="random-color-btn" data-target="calendarLunarColor" title="隨機顏色">🎨</button></div></div> <!-- 月曆農曆顏色選擇器 -->
				</div> <!-- 第三欄設定結束 -->
				<div class="settings-column"> <!-- 第四欄設定 -->
					<h3>通用</h3> <!-- 區塊標題 -->
					<div class="setting-item"><div class="location-input-group"><select id="countySelect" class="interval-select" style="max-width: 85px;"></select><select id="districtSelect" class="interval-select" style="max-width: 85px;"></select><input id="weatherLocation" type="text" class="interval-select" title="可手動輸入英文地名" placeholder="手動輸入(英文)" style="width: 120px; margin-left: 5px;"></div><div class="location-controls-group"><button id="useCurrentLocationBtn" title="使用目前位置"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L12 6"/><path d="M12 18L12 22"/><path d="M20 12L22 12"/><path d="M2 12L4 12"/><circle cx="12" cy="12" r="2"/><path d="M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16z"/></svg></button></div></div> <!-- 地區選擇（縣市、區）和定位按鈕 -->
					<div class="setting-item"><label for="enableMovement">隨機移動</label><div class="setting-controls"><div class="interval-selector-group"><select id="movementIntervalMinutes" class="interval-select"></select><span class="interval-select-label">分</span><select id="movementIntervalSeconds" class="interval-select"></select><span class="interval-select-label">秒</span></div><label class="switch"><input id="enableMovement" type="checkbox"><span class="slider"></span></label></div></div> <!-- 啟用/禁用隨機移動及間隔設定 -->
					<div class="setting-item"><label for="enableTextScanline">文字掃描線</label><div class="setting-controls"><div class="interval-selector-group"><select id="scanlineIntervalMinutes" class="interval-select"></select><span class="interval-select-label">分</span><select id="scanlineIntervalSeconds" class="interval-select"></select><span class="interval-select-label">秒</span></div><label class="switch"><input id="enableTextScanline" type="checkbox"><span class="slider"></span></label></div></div> <!-- 啟用/禁用文字掃描線及間隔設定 -->
					<div class="setting-item"><label for="enableBackgroundScanline">背景掃描線</label><div class="setting-controls"><label class="switch"><input id="enableBackgroundScanline" type="checkbox"><span class="slider"></span></label></div></div> <!-- 啟用/禁用背景掃描線 -->
					<div class="setting-item"><label for="backgroundColor">背景顏色</label><div class="setting-controls"><input id="backgroundColor" type="color"><button class="random-color-btn" data-target="backgroundColor" title="隨機顏色">🎨</button></div></div> <!-- 背景顏色選擇器 -->
				</div> <!-- 第四欄設定結束 -->
			</div> <!-- 設定項目多欄容器結束 -->
			<div class="button-group"><button class="action-button" id="restoreDefaultsBtn">恢復預設</button><button class="action-button" id="randomColorsBtn">隨機顏色</button></div> <!-- 操作按鈕群組 -->
		</div> <!-- 彈出視窗內容結束 -->
	</div> <!-- 設定彈出視窗結束 -->
	<div class="modal" id="dateDetailsModal"><div class="modal-content details-content"><span class="close-icon">&times;</span><div class="modal-header"><h2 id="dateDetailsModalTitle">當日詳情</h2></div><div id="dateDetailsModalContent"></div></div></div> <!-- 當日詳情彈出視窗 -->
	<div class="modal" id="shichenDetailsModal"><div class="modal-content details-content"><span class="close-icon">&times;</span><div class="modal-header"><button id="prevShichenBtn">&lt;</button><h2 id="shichenDetailsModalTitle">時辰詳情</h2><button id="nextShichenBtn">&gt;</button></div><div id="shichenDetailsModalContent"></div><div class="button-group"><button class="action-button" id="nowShichenBtn">現在</button></div></div></div> <!-- 時辰詳情彈出視窗 -->
	<div class="modal" id="calendarModal"><div class="modal-content calendar-content"><span class="close-icon">&times;</span><div class="modal-header"><button id="prevMonthBtn">&lt;</button><h2 id="calendarMonthYear"></h2><button id="nextMonthBtn">&gt;</button></div><div class="calendar-weekdays" id="calendarWeekdays"></div><div class="calendar-grid" id="calendarGrid"></div><div class="calendar-footer"><button class="action-button" id="todayCalendarBtn">今天</button></div></div></div> <!-- 月曆彈出視窗 -->
	<div class="modal" id="weeklyCalendarModal"><div class="modal-content weekly-calendar-content"><span class="close-icon">&times;</span><div class="modal-header"><button id="prevWeekBtn">&lt;</button><h2 id="weeklyCalendarTitle"></h2><button id="nextWeekBtn">&gt;</button></div><div class="weekly-calendar-grid" id="weeklyCalendarGrid"></div><div class="calendar-footer"><button class="action-button" id="todayWeeklyBtn">本週</button></div></div></div> <!-- 週曆彈出視窗 -->
	<div class="modal" id="yearlyCalendarModal"><div class="modal-content yearly-calendar-content"><span class="close-icon">&times;</span><div class="modal-header"><button id="prevYearBtn">&lt;</button><h2 id="yearlyCalendarTitle"></h2><button id="nextYearBtn">&gt;</button></div><div class="yearly-calendar-grid" id="yearlyCalendarGrid"></div><div class="calendar-footer"><button class="action-button" id="todayYearlyBtn">今年</button></div></div></div> <!-- 年曆彈出視窗 -->
	<div class="modal" id="weatherForecastModal"><div class="modal-content"><span class="close-icon">&times;</span><div class="modal-header"><h2 id="weatherForecastModalTitle">未來一週天氣預報</h2></div><div class="weather-forecast-grid" id="weatherForecastGrid"></div></div></div> <!-- 天氣預報彈出視窗 -->
	<div class="modal" id="hourlyWeatherModal"><div class="modal-content"><span class="close-icon">&times;</span><div class="modal-header"><h2 id="hourlyWeatherModalTitle">每小時天氣預報</h2></div><div class="hourly-weather-grid" id="hourlyWeatherGrid"></div><div class="button-group"><button class="action-button" id="backToWeeklyForecastBtn">返回週預報</button></div></div></div> <!-- 每小時天氣預報彈出視窗 -->
	<div class="modal" id="moonPhaseModal"> <!-- 月相彈出視窗 -->
		<div class="modal-content details-content"> <!-- 彈出視窗內容 -->
			<span class="close-icon">&times;</span> <!-- 關閉按鈕 -->
			<div class="modal-header"><h2 id="moonPhaseModalTitle">月相詳情</h2></div> <!-- 標頭 -->
			<div id="moonPhaseModalContent"> <!-- 內容主體 -->
				<div id="moonPhaseDisplay"><div class="moon-phase-icon-large" id="mainMoonIcon"></div><p id="mainMoonDescription"></p></div> <!-- 主要月相顯示區 -->
				<div class="moon-calendar-container"> <!-- 月相日曆容器 -->
					<div class="modal-header"><button id="prevMoonMonthBtn">&lt;</button><h3 id="moonCalendarMonthYear"></h3><button id="nextMoonMonthBtn">&gt;</button></div> <!-- 月相日曆標頭與切換按鈕 -->
					<div class="calendar-weekdays" id="moonCalendarWeekdays"></div> <!-- 星期標頭 -->
					<div class="calendar-grid" id="moonCalendarGrid"></div> <!-- 日期網格 -->
				</div> <!-- 月相日曆容器結束 -->
			</div> <!-- 內容主體結束 -->
			<div class="button-group"><button class="action-button" id="todayMoonCalendarBtn">今天</button></div> <!-- 操作按鈕 -->
		</div> <!-- 彈出視窗內容結束 -->
	</div> <!-- 月相彈出視窗結束 -->
	<div class="modal" id="zodiacModal"> <!-- 生肖彈出視窗 -->
		<div class="modal-content"> <!-- 彈出視窗內容 -->
			<span class="close-icon">&times;</span> <!-- 關閉按鈕 -->
			<div class="modal-header"><h2 id="zodiacModalTitle">十二生肖</h2></div> <!-- 標頭 -->
			<div class="zodiac-grid" id="zodiacGrid"></div> <!-- 生肖網格 -->
		</div> <!-- 彈出視窗內容結束 -->
	</div> <!-- 生肖彈出視窗結束 -->
	<div id="edit-mode-icon" class="control-icon" title="編輯模式"> <!-- 編輯模式切換圖示 -->
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"> <!-- SVG 圖示 -->
			<g class="wrench-icon"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path></g> <!-- 扳手圖示 -->
			<g class="close-icon-svg" style="display: none;"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></g> <!-- 關閉圖示（叉叉），預設隱藏 -->
		</svg> <!-- SVG 圖示結束 -->
	</div> <!-- 編輯模式圖示結束 -->
	<div id="settings-icon" class="control-icon" title="設定"> <!-- 設定圖示 -->
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61-.25-1.17-.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg> <!-- 齒輪 SVG 圖示 -->
	</div> <!-- 設定圖示結束 -->
	<div id="fullscreen-icon" class="control-icon" title="全螢幕"> <!-- 全螢幕切換圖示 -->
		<svg class="enter-fullscreen-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></svg> <!-- 進入全螢幕的圖示 -->
		<svg class="exit-fullscreen-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="display: none;"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"></path></svg> <!-- 退出全螢幕的圖示，預設隱藏 -->
	</div> <!-- 全螢幕圖示結束 -->
	<script>
		let settings = {}, transformState = {}; // 初始化設定物件和變形狀態物件
		let timers = { main: null, movement: null, scanline: null, weather: null, analog: null }; // 初始化所有計時器
		let state = { // 初始化應用程式的狀態物件
			scanlinePatternIsA: true, lastMarqueeContent: '', lastWeatherContent: '', // 掃描線樣式、上次跑馬燈內容
			calendarDate: new Date(), weeklyCalendarDate: new Date(), yearlyCalendarDate: new Date(), // 各種日曆的目前日期
			shichenDetailDate: new Date(), moonCalendarDate: new Date(), // 時辰和月相詳情的日期
			yearlyDataCache: { year: -1, holidays: [], jieqi: [] }, weatherDataCache: null, // 年度資料和天氣資料的快取
			isDragging: false, dragTarget: null, dragType: null, startX: 0, startY: 0, // 拖曳狀態相關變數
			initialX: 0, initialY: 0, initialScale: 1, initialDist: 0, initialWidth: 0, // 拖曳初始值
			movementEnabledBeforeEdit: true, // 記錄進入編輯模式前的移動設定
		};
		const taiwanLocations = { "台灣": { "english": "taiwan", "districts": { "台灣": "taiwan" } }, "基隆市": { "english": "keelung", "districts": { "基隆市": "keelung", "仁愛區": "renai", "信義區": "xinyi", "中正區": "zhongzheng", "中山區": "zhongshan", "安樂區": "anle", "暖暖區": "nuannuan", "七堵區": "qidu" } }, "臺北市": { "english": "taipei", "districts": { "臺北市": "taipei", "中正區": "zhongzheng", "大同區": "datong", "中山區": "zhongshan", "松山區": "songshan", "大安區": "da'an", "萬華區": "wanhua", "信義區": "xinyi", "士林區": "shilin", "北投區": "beitou", "內湖區": "neihu", "南港區": "nangang", "文山區": "wenshan" } }, "新北市": { "english": "new taipei", "districts": { "新北市": "new taipei", "板橋區": "banqiao", "三重區": "sanchong", "中和區": "zhonghe", "永和區": "yonghe", "新莊區": "xinzhuang", "新店區": "xindian", "土城區": "tucheng", "蘆洲區": "luzhou", "樹林區": "shulin", "汐止區": "xizhi", "鶯歌區": "yingge", "三峽區": "sanxia", "淡水區": "danshui", "瑞芳區": "ruifang", "五股區": "wugu", "泰山區": "taishan", "林口區": "linkou", "深坑區": "shengkeng", "石碇區": "shiding", "坪林區": "pinglin", "三芝區": "sanzhi", "石門區": "shimen", "八里區": "bali", "平溪區": "pingxi", "雙溪區": "shuangxi", "貢寮區": "gongliao", "金山區": "jinshan", "萬里區": "wanli", "烏來區": "wulai" } }, "桃園市": { "english": "taoyuan", "districts": { "桃園市": "taoyuan", "桃園區": "taoyuan", "中壢區": "zhongli", "平鎮區": "pingzhen", "八德區": "bade", "楊梅區": "yangmei", "蘆竹區": "luzhu", "大溪區": "daxi", "龍潭區": "longtan", "龜山區": "guishan", "大園區": "dayuan", "觀音區": "guanyin", "新屋區": "xinwu", "復興區": "fuxing" } }, "臺中市": { "english": "taichung", "districts": { "臺中市": "taichung", "中區": "central", "東區": "east", "南區": "south", "西區": "west", "北區": "north", "北屯區": "beitun", "西屯區": "xitun", "南屯區": "nantun", "太平區": "taiping", "大里區": "dali", "霧峰區": "wufeng", "烏日區": "wuri", "豐原區": "fengyuan", "后里區": "houli", "石岡區": "shigang", "東勢區": "dongshi", "和平區": "heping", "新社區": "xinshe", "潭子區": "tanzi", "大雅區": "daya", "神岡區": "shengang", "大肚區": "dadu", "沙鹿區": "shalu", "龍井區": "longjing", "梧棲區": "wuqi", "清水區": "qingshui", "大甲區": "dajia", "外埔區": "waipu", "大安區": "daan" } }, "臺南市": { "english": "tainan", "districts": { "臺南市": "tainan", "中西區": "west central", "東區": "east", "南區": "south", "北區": "north", "安平區": "anping", "安南區": "annan", "永康區": "yongkang", "歸仁區": "guiren", "新化區": "xinhua", "左鎮區": "zuozhen", "玉井區": "yujing", "楠西區": "nanxi", "南化區": "nanhua", "仁德區": "rende", "關廟區": "guanmiao", "龍崎區": "longqi", "官田區": "guantian", "麻豆區": "madou", "佳里區": "jiali", "西港區": "xigang", "七股區": "qigu", "將軍區": "jiangjun", "學甲區": "xuejia", "北門區": "beimen", "新營區": "xinying", "後壁區": "houbi", "白河區": "baihe", "東山區": "dongshan", "六甲區": "liujia", "下營區": "xiaying", "柳營區": "liuying", "鹽水區": "yanshui", "善化區": "shanhua", "大內區": "danei", "山上區": "shanshang", "新市區": "xingshi", "安定區": "anding" } }, "高雄市": { "english": "kaohsiung", "districts": { "高雄市": "kaohsiung", "楠梓區": "nanzi", "左營區": "zuoying", "鼓山區": "gushan", "三民區": "sanmin", "鹽埕區": "yancheng", "前金區": "qianjin", "新興區": "xinxing", "苓雅區": "lingya", "前鎮區": "qianzhen", "旗津區": "qijin", "小港區": "xiaogang", "鳳山區": "fengshan", "林園區": "linyuan", "大寮區": "daliao", "大樹區": "dashu", "大社區": "dashe", "仁武區": "renwu", "鳥松區": "niaosong", "岡山區": "gangshan", "橋頭區": "qiaotou", "燕巢區": "yanchao", "田寮區": "tianliao", "阿蓮區": "alian", "路竹區": "luzhu", "湖內區": "hunei", "茄萣區": "qieding", "永安區": "yong'an", "彌陀區": "mizuo", "梓官區": "ziguan", "旗山區": "qishan", "美濃區": "meinong", "六龜區": "liugui", "甲仙區": "jiaxian", "杉林區": "shanlin", "內門區": "neimen", "茂林區": "maolin", "桃源區": "taoyuan", "那瑪夏區": "namasia" } }, "新竹縣": { "english": "hsinchu county", "districts": { "新竹縣": "hsinchu county", "竹北市": "zhubei", "竹東鎮": "zhudong", "新埔鎮": "xinpu", "關西鎮": "guanxi", "湖口鄉": "hukou", "新豐鄉": "xinfeng", "芎林鄉": "qionglin", "橫山鄉": "hengshan", "北埔鄉": "beipu", "寶山鄉": "baoshan", "峨眉鄉": "emei", "尖石鄉": "jianshi", "五峰鄉": "wufeng" } }, "苗栗縣": { "english": "miaoli", "districts": { "苗栗縣": "miaoli", "苗栗市": "miaoli city", "頭份市": "toufen", "苑裡鎮": "yuanli", "通霄鎮": "tongxiao", "竹南鎮": "zhunan", "後龍鎮": "houlong", "卓蘭鎮": "zhuolan", "大湖鄉": "dahu", "公館鄉": "gongguan", "銅鑼鄉": "tongluo", "南庄鄉": "nanzhuang", "頭屋鄉": "touwu", "三灣鄉": "sanwan", "三義鄉": "sanyi", "西湖鄉": "xihu", "造橋鄉": "zaoqiao", "獅潭鄉": "shitan", "泰安鄉": "taian" } }, "彰化縣": { "english": "changhua", "districts": { "彰化縣": "changhua", "彰化市": "changhua city", "員林市": "yuanlin", "和美鎮": "hemei", "鹿港鎮": "lukang", "溪湖鎮": "xihu", "田中鎮": "tianzhong", "北斗鎮": "beidou", "二林鎮": "erlin", "線西鄉": "xianxi", "伸港鄉": "shengang", "福興鄉": "fuxing", "秀水鄉": "xiushui", "花壇鄉": "huatan", "芬園鄉": "fenyuan", "大村鄉": "dacun", "埔鹽鄉": "puyan", "埔心鄉": "puxin", "永靖鄉": "yongjing", "社頭鄉": "shetou", "二水鄉": "ershui", "田尾鄉": "tianwei", "埤頭鄉": "pitou", "芳苑鄉": "fangyuan", "大城鄉": "dacheng", "竹塘鄉": "zhutang", "溪州鄉": "xizhou" } }, "南投縣": { "english": "nantou", "districts": { "南投縣": "nantou", "南投市": "nantou city", "埔里鎮": "puli", "草屯鎮": "caotun", "竹山鎮": "zhushan", "集集鎮": "jiji", "名間鄉": "mingjian", "鹿谷鄉": "lugu", "中寮鄉": "zhongliao", "魚池鄉": "yuchi", "國姓鄉": "guoxing", "水里鄉": "shuili", "信義鄉": "xinyi", "仁愛鄉": "ren'ai" } }, "雲林縣": { "english": "yunlin", "districts": { "雲林縣": "yunlin", "斗六市": "douliu", "斗南鎮": "dounan", "虎尾鎮": "huwei", "西螺鎮": "xiluo", "土庫鎮": "tuku", "北港鎮": "beigang", "古坑鄉": "gukeng", "大埤鄉": "dapi", "莿桐鄉": "citong", "林內鄉": "linnei", "二崙鄉": "erlun", "崙背鄉": "lunbei", "麥寮鄉": "mailiao", "東勢鄉": "dongshi", "褒忠鄉": "baozhong", "臺西鄉": "taixi", "元長鄉": "yuanchang", "四湖鄉": "sihu", "口湖鄉": "kouhu", "水林鄉": "shuilin" } }, "嘉義縣": { "english": "chiayi county", "districts": { "嘉義縣": "chiayi county", "太保市": "taibao", "朴子市": "puzi", "布袋鎮": "budai", "大林鎮": "dalin", "民雄鄉": "minxiong", "溪口鄉": "xikou", "新港鄉": "xingang", "六腳鄉": "liujiao", "東石鄉": "dongshi", "義竹鄉": "yizu", "鹿草鄉": "lucao", "水上鄉": "shuishang", "中埔鄉": "zhongpu", "竹崎鄉": "zhuqi", "梅山鄉": "meishan", "番路鄉": "fanlu", "大埔鄉": "dapu", "阿里山鄉": "alishan" } }, "屏東縣": { "english": "pingtung", "districts": { "屏東縣": "pingtung", "屏東市": "pingtung city", "潮州鎮": "chaozhou", "東港鎮": "donggang", "恆春鎮": "hengchun", "萬丹鄉": "wandan", "長治鄉": "changzhi", "麟洛鄉": "linluo", "九如鄉": "jiuru", "里港鄉": "ligang", "鹽埔鄉": "yanpu", "高樹鄉": "gaoshu", "萬巒鄉": "wanluan", "內埔鄉": "neipu", "竹田鄉": "zhutian", "新埤鄉": "xinpi", "枋寮鄉": "fangliao", "新園鄉": "xinyuan", "崁頂鄉": "kanding", "林邊鄉": "linbian", "南州鄉": "nanzhou", "佳冬鄉": "jiadong", "琉球鄉": "liuqiu", "車城鄉": "checheng", "滿州鄉": "manzhou", "枋山鄉": "fangshan", "三地門鄉": "sandimen", "霧臺鄉": "wutai", "瑪家鄉": "majia", "泰武鄉": "taiwu", "來義鄉": "laiyi", "春日鄉": "chunri", "獅子鄉": "shizi", "牡丹鄉": "mudan" } }, "宜蘭縣": { "english": "yilan", "districts": { "宜蘭縣": "yilan", "宜蘭市": "yilan city", "羅東鎮": "luodong", "蘇澳鎮": "su'ao", "頭城鎮": "toucheng", "礁溪鄉": "jiaoxi", "壯圍鄉": "zhuangwei", "員山鄉": "yuanshan", "冬山鄉": "dongshan", "五結鄉": "wujie", "三星鄉": "sanxing", "大同鄉": "datong", "南澳鄉": "nan'ao" } }, "花蓮縣": { "english": "hualien", "districts": { "花蓮縣": "hualien", "花蓮市": "hualien city", "鳳林鎮": "fenglin", "玉里鎮": "yuli", "新城鄉": "xincheng", "吉安鄉": "ji'an", "壽豐鄉": "shoufeng", "光復鄉": "guangfu", "豐濱鄉": "fengbin", "瑞穗鄉": "ruisui", "富里鄉": "fuli", "秀林鄉": "xiulin", "萬榮鄉": "wanrong", "卓溪鄉": "zhuoxi" } }, "臺東縣": { "english": "taitung", "districts": { "臺東縣": "taitung", "臺東市": "taitung city", "成功鎮": "chenggong", "關山鎮": "guanshan", "卑南鄉": "beinan", "鹿野鄉": "luye", "池上鄉": "chishang", "東河鄉": "donghe", "長濱鄉": "changbin", "太麻里鄉": "taimali", "大武鄉": "dawu", "達仁鄉": "daren", "金峰鄉": "jinfeng", "海端鄉": "haiduan", "延平鄉": "yanping", "綠島鄉": "ludao", "蘭嶼鄉": "lanyu" } }, "澎湖縣": { "english": "penghu", "districts": { "澎湖縣": "penghu", "馬公市": "magong", "湖西鄉": "huxi", "白沙鄉": "baisha", "西嶼鄉": "xiyu", "望安鄉": "wang'an", "七美鄉": "qimei" } }, "金門縣": { "english": "kinmen", "districts": { "金門縣": "kinmen", "金城鎮": "jincheng", "金湖鎮": "jinhu", "金沙鎮": "jinsha", "金寧鄉": "jinning", "烈嶼鄉": "lieyu", "烏坵鄉": "wuqiu" } }, "連江縣": { "english": "lienchiang", "districts": { "連江縣": "lienchiang", "南竿鄉": "nangan", "北竿鄉": "beigan", "莒光鄉": "juguang", "東引鄉": "dongyin" } }, "新竹市": { "english": "hsinchu", "districts": { "新竹市": "hsinchu", "東區": "east", "北區": "north", "香山區": "xiangshan" } }, "嘉義市": { "english": "chiayi", "districts": { "嘉義市": "chiayi", "東區": "east", "西區": "west" } } }; // 台灣各地區中英文對照表
		const defaultSettings = { // 定義所有設定的預設值
			backgroundColor: '#000000', enableMovement: true, movementIntervalMinutes: 0, movementIntervalSeconds: 10, showWeather: true, // 背景、移動、天氣相關設定
			weatherLocation: 'taiwan', weatherColor: '#87CEFA', showWeatherLocation: true, weatherLocationColor: '#00FFFF', showDigitalTime: true, // 天氣地點、顏色、數位時間顯示設定
			showGregorianDate: true, showLunarDate: true, showAmPm: true, showGregorianYear: true, showGregorianMonth: true, showGregorianDay: true, // 公農曆、12/24小時制、年月日顯示設定
			showGregorianWeekday: true, showMinguoYear: true, showLunarMonth: true, showLunarDay: true, showLunarShiChen: true, showJieqi: true, // 星期、民國年、農曆月日時辰節氣顯示設定
			showHolidays: true, hourColor: '#00FF00', minuteColor: '#00FF00', colonColor: '#00FF00', secondColor: '#00FF00', amPmColor: '#00FF00', // 節日顯示與數位時間各部分顏色
			gregorianYearColor: '#00FF00', gregorianMonthColor: '#00FF00', gregorianDayColor: '#00FF00', gregorianWeekdayColor: '#00FF00', // 公曆各部分顏色
			minguoYearColor: '#00FF00', lunarMonthColor: '#00FF00', lunarDayColor: '#00FF00', lunarShiChenColor: '#00FF00', jieqiColor: '#00FF00', // 農曆各部分顏色
			holidayColor: '#00FFFF', enableTextScanline: false, enableBackgroundScanline: false, scanlineIntervalMinutes: 0, scanlineIntervalSeconds: 10, // 節日顏色與掃描線效果設定
			showAnalogClock: false, showAnalogCalendar: false, hourHandColor: '#ffffff', minuteHandColor: '#ffffff', secondHandColor: '#ff5b3f', // 類比時鐘/日曆顯示與指針顏色
			tickColor: '#ffffff', numberColor: '#ffffff', calendarHeaderColor: '#ff5b3f', calendarWeekdayColor: '#00ffff', calendarDayColor: '#ffffff', // 類比時鐘刻度、數字與日曆顏色
			calendarLunarColor: '#aaaaaa', // 類比日曆農曆顏色
		};
		const defaultTransformState = { // 定義所有元件的預設位置、大小
			'master': { x: 0, y: 0, scale: 1 }, 'digital': { x: 0, y: -120, scale: 1 }, 'gregorian-date': { x: 0, y: 80, scale: 1, width: 92 }, // 主容器、數位時間、公曆日期
			'lunar-date': { x: 0, y: 150, scale: 1, width: 92 }, 'analog-clock': { x: 0, y: -150, scale: 0.8 }, 'analog-calendar': { x: 0, y: 150, scale: 0.8 } // 農曆日期、類比時鐘、類比日曆
		};
		const qs = (selector) => document.querySelector(selector); // querySelector 的縮寫函式
		const qsa = (selector) => document.querySelectorAll(selector); // querySelectorAll 的縮寫函式
		const setStyle = (element, styles) => Object.assign(element.style, styles); // 快速設定多個 CSS 樣式的函式
		function saveState() { try { localStorage.setItem('mergedClockSettings_v4', JSON.stringify(settings)); localStorage.setItem('mergedClockTransforms_v4', JSON.stringify(transformState)); } catch (e) { console.error("儲存狀態失敗:", e); } } // 將目前的設定和位置狀態存到 localStorage
		function loadState() { try { const storedSettings = localStorage.getItem('mergedClockSettings_v4'); settings = storedSettings ? { ...defaultSettings, ...JSON.parse(storedSettings) } : { ...defaultSettings }; const storedTransforms = localStorage.getItem('mergedClockTransforms_v4'); transformState = storedTransforms ? { ...defaultTransformState, ...JSON.parse(storedTransforms) } : { ...defaultTransformState }; } catch (e) { console.error("解析狀態失敗:", e); settings = { ...defaultSettings }; transformState = { ...defaultTransformState }; } settings.editMode = false; } // 從 localStorage 載入設定和位置狀態，若失敗則使用預設值
		function updateSettingsModalUI() { for (const key in settings) { const el = document.getElementById(key); if (el) { if (el.type === 'checkbox') el.checked = settings[key]; else if (el.tagName !== 'SELECT' || !['countySelect', 'districtSelect'].includes(key)) el.value = settings[key]; } } setLocationSelectorsFromEnglish(settings.weatherLocation); } // 根據目前的 settings 物件更新設定面板中的所有 UI 元件
		function restoreDefaults() { // 恢復所有設定為預設值
			settings = { ...defaultSettings }; // 將設定物件重設為預設值
			transformState = { ...defaultTransformState }; // 將位置狀態物件重設為預設值
			settings.editMode = false;  // 確保退出編輯模式
			state.movementEnabledBeforeEdit = true; // 重設編輯模式前的移動狀態
			saveState(); // 儲存預設狀態
			updateSettingsModalUI(); // 更新設定面板 UI
			toggleEditModeState(); // 切換編輯模式狀態 (會觸發 applyMovement)
			applyAllSettings(); // 應用所有視覺設定
			applyTransforms(); // 應用所有位置設定
			updateWidgetVisibility(); // 更新元件可見性
			applyScanlineEffect(); // 應用掃描線效果
			updateSettingDependencies(); // 更新設定項目的連動狀態
			state.lastMarqueeContent = ''; // 清除跑馬燈快取
			state.lastWeatherContent = ''; // 清除天氣快取
			updateWeather(); // 立即更新天氣資訊
		}
		function setRandomColors() { for (const key in settings) { if (key.toLowerCase().includes('color')) settings[key] = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'); } saveState(); updateSettingsModalUI(); applyAllSettings(); } // 將所有顏色設定為隨機值
		function initializeTimers() { Object.values(timers).forEach(clearInterval); timers.main = setInterval(updateDigitalClock, 1000); timers.analog = setInterval(updateAnalogClock, 50); applyMovement(); applyScanlineEffect(); } // 初始化所有計時器
		function getEncompassingBoundingBox(elements) { // 計算一組 DOM 元素集合的整體邊界框
			let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity, hasVisibleElements = false; // 初始化邊界值
			elements.forEach(el => { if (window.getComputedStyle(el).display !== 'none') { hasVisibleElements = true; const rect = el.getBoundingClientRect(); minX = Math.min(minX, rect.left); minY = Math.min(minY, rect.top); maxX = Math.max(maxX, rect.right); maxY = Math.max(maxY, rect.bottom); } }); // 遍歷所有可見元素並更新邊界
			if (!hasVisibleElements) return null; // 如果沒有可見元素，返回 null
			return { left: minX, top: minY, right: maxX, bottom: maxY, width: maxX - minX, height: maxY - minY }; // 返回計算後的邊界物件
		}
		function applyMovement() { // 根據設定啟用或停用隨機移動
			clearInterval(timers.movement); // 清除舊的移動計時器
			if (settings.editMode) return; // 編輯模式下不移動
			if (settings.enableMovement) { // 如果啟用移動
				const intervalMs = (parseInt(settings.movementIntervalMinutes) * 60 + parseInt(settings.movementIntervalSeconds)) * 1000; // 計算移動間隔毫秒數
				if (intervalMs > 0) { // 如果間隔大於 0
					moveRandomly(); // 立即移動一次
					timers.movement = setInterval(moveRandomly, intervalMs); // 設定新的移動計時器
				}
			} else { // 如果停用移動
				if (transformState['master']) { // 將主容器歸位
					transformState['master'].x = 0; // X 座標歸零
					transformState['master'].y = 0; // Y 座標歸零
				}
				applyTransforms(); // 應用歸位後的變形
			}
		}
		function applyScanlineEffect() { // 應用掃描線效果
			clearInterval(timers.scanline); // 清除舊的掃描線計時器
			const bg = qs('#background-scanline-overlay'), txt = qs('#text-scanline-overlay'); // 獲取掃描線圖層元素
			bg.classList.toggle('active', settings.enableBackgroundScanline); // 根據設定切換背景掃描線的 active class
			txt.classList.toggle('active', settings.enableTextScanline); // 根據設定切換文字掃描線的 active class
			if (settings.enableBackgroundScanline || settings.enableTextScanline) { // 如果任一掃描線啟用
				const intervalMs = (parseInt(settings.scanlineIntervalMinutes) * 60 + parseInt(settings.scanlineIntervalSeconds)) * 1000; // 計算切換間隔
				if (intervalMs > 0) { timers.scanline = setInterval(() => { state.scanlinePatternIsA = !state.scanlinePatternIsA; updateDigitalClock(); }, intervalMs); } // 設定計時器定時切換掃描線樣式
			}
		}
		function hexToRgba(hex, alpha = 1) { if (!hex || !hex.startsWith('#')) return `rgba(255, 255, 255, ${alpha})`; const bigint = parseInt(hex.slice(1), 16); const r = (bigint >> 16) & 255, g = (bigint >> 8) & 255, b = bigint & 255; return `rgba(${r}, ${g}, ${b}, ${alpha})`; } // 將 HEX 顏色碼轉換為 RGBA 格式
		function applyAllSettings() { // 應用所有與視覺相關的設定
			document.documentElement.style.setProperty('--page-background-color', settings.backgroundColor); // 設定頁面背景色
			['hourHandColor', 'minuteHandColor', 'secondHandColor', 'tickColor', 'numberColor', 'calendarHeaderColor', 'calendarWeekdayColor', 'calendarDayColor', 'calendarLunarColor'].forEach(key => { if (settings[key]) document.documentElement.style.setProperty('--' + key.replace(/([A-Z])/g, '-$1').toLowerCase(), settings[key]); }); // 遍歷並設定所有 CSS 變數
			const bgMonthColor = hexToRgba(settings.calendarHeaderColor, 0.12); // 計算日曆背景月份的半透明顏色
			qsa('.calendar-bg-month, .analog-calendar-bg-month').forEach(el => el.style.color = bgMonthColor); // 應用日曆背景月份顏色
			updateWeatherDisplay(); updateDigitalClock(); updateAnalogClock(); // 更新天氣、數位和類比時鐘的顯示
		}
		function moveRandomly() { // 將元件群組隨機移動到螢幕內的一個位置
			if (settings.editMode) return; // 編輯模式下不移動
			const id = 'master'; // 我們只移動主容器
			if (!transformState[id]) transformState[id] = { x: 0, y: 0, scale: 1 }; // 初始化主容器的變形狀態
			const T = transformState[id]; // 獲取主容器的變形狀態
			const allWidgets = qsa('.widget-wrapper'); // 獲取所有元件
			const bbox = getEncompassingBoundingBox(allWidgets); // 計算所有可見元件的整體邊界
			if (!bbox) return; // 如果沒有可見元件，則不移動
			const scaledWidth = bbox.width / T.scale; // 計算縮放後的實際寬度
			const scaledHeight = bbox.height / T.scale; // 計算縮放後的實際高度
			const margin = 10; // 設定與螢幕邊緣的間距
			const maxX = (window.innerWidth - scaledWidth) / 2 - margin; // 計算 X 軸最大可移動範圍
			const maxY = (window.innerHeight - scaledHeight) / 2 - margin; // 計算 Y 軸最大可移動範圍
			if (maxX > 0 && maxY > 0) { // 如果元件群組比螢幕小
				T.x = Math.random() * (maxX * 2) - maxX; // 在範圍內產生隨機 X 座標
				T.y = Math.random() * (maxY * 2) - maxY; // 在範圍內產生隨機 Y 座標
			} else { // 如果元件群組比螢幕大
				T.x = 0; // X 座標置中
				T.y = 0; // Y 座標置中
			}
			applyTransforms(); // 應用新的座標
		}
		function applyTransforms() { // 將 transformState 物件中的變形應用到對應的 DOM 元素
			const masterEl = qs('#master-layout'), T_master = transformState['master'] || defaultTransformState['master']; // 獲取主容器元素和其變形狀態
			if(masterEl) { masterEl.style.transition = state.isDragging ? 'none' : 'transform 1s ease-in-out'; masterEl.style.transform = `translate(calc(-50% + ${T_master.x}px), calc(-50% + ${T_master.y}px)) scale(${T_master.scale})`; } // 應用主容器的位移和縮放
			for (const id in transformState) { // 遍歷所有元件的變形狀態
				if (id === 'master') continue; // 跳過主容器
				const el = qs(`#${id}-widget`); // 獲取元件
				if (el) { // 如果元件存在
					const T = transformState[id]; // 獲取其變形狀態
					el.style.transition = state.isDragging ? 'none' : 'transform 1s ease-in-out'; // 設定過渡效果 (拖曳時禁用)
					el.style.transform = `translate(calc(-50% + ${T.x}px), calc(-50% + ${T.y}px)) scale(${T.scale})`; // 應用位移和縮放
					const invScale = 1 / T.scale; // 計算反向縮放比例，以保持控制項大小不變
					const handle = el.querySelector('.move-handle'); // 獲取移動控制項
					if (handle) handle.style.transform = `translate(-50%, -50%) scale(${invScale})`; // 應用反向縮放
					const resizeHandleX = el.querySelector('.resize-handle-x'); // 獲取寬度調整控制項
					if (resizeHandleX) resizeHandleX.style.transform = `translateY(-50%) scale(${invScale})`; // 應用反向縮放
					if (T.width) { const contentEl = qs(`#${id}-widget > div:first-child`); if(contentEl) contentEl.style.width = `${T.width}vw`; } // 如果有寬度設定，則應用
				}
			}
		}
		function toggleEditModeState() { // 切換編輯模式的 UI 和行為
			document.body.classList.toggle('edit-mode', settings.editMode); // 切換 body 的 'edit-mode' class
			const wrenchIcon = qs('#edit-mode-icon .wrench-icon'), closeIcon = qs('#edit-mode-icon .close-icon-svg'); // 獲取編輯圖示
			if (wrenchIcon && closeIcon) { // 如果圖示存在
				wrenchIcon.style.display = settings.editMode ? 'none' : 'block'; // 根據編輯模式顯示/隱藏扳手圖示
				closeIcon.style.display = settings.editMode ? 'block' : 'none'; // 根據編輯模式顯示/隱藏關閉圖示
			}
			qs('#edit-mode-icon').title = settings.editMode ? '結束編輯' : '編輯模式'; // 更新圖示的 title
			if (settings.editMode) { // 如果進入編輯模式
				state.movementEnabledBeforeEdit = settings.enableMovement; // 儲存當前的移動設定
				settings.enableMovement = false; // 暫時禁用移動
				qs('#enableMovement').checked = false; // 更新設定面板中的開關
				if (transformState['master']) { // 將主容器歸位到中心
					transformState['master'].x = 0; // X 座標歸零
					transformState['master'].y = 0; // Y 座標歸零
				}
				applyTransforms(); // 應用歸位效果
			} else { // 如果退出編輯模式
				settings.enableMovement = state.movementEnabledBeforeEdit; // 恢復之前的移動設定
				qs('#enableMovement').checked = state.movementEnabledBeforeEdit; // 更新設定面板中的開關
			}
			applyMovement(); // 根據新的移動設定來啟動或停止計時器
			updateSettingDependencies(); // 更新設定面板中選項的連動狀態
		}
		function updateSettingDependencies() { // 更新設定面板中各選項之間的連動禁用/啟用狀態
			const toggleSettingGroup = (parentSelector, childSelectors, isParentEnabled) => { // 輔助函式，用於切換一組子設定的狀態
				const parentSwitch = qs(parentSelector); if (!parentSwitch) return; // 獲取父開關
				const isEnabled = isParentEnabled && parentSwitch.checked; // 判斷是否應啟用子設定
				childSelectors.forEach(selector => { const element = qs(selector); if (!element) return; const item = element.closest('.setting-item'); if (item) { item.classList.toggle('disabled', !isEnabled); item.querySelectorAll('input, select, button').forEach(ctrl => ctrl.disabled = !isEnabled); } }); // 切換子設定的 disabled class 和 disabled 屬性
			};
			const isGregorianOn = qs('#showGregorianDate').checked, isWeatherOn = qs('#showWeather').checked, isWeatherLocationOn = qs('#showWeatherLocation').checked; // 獲取幾個關鍵設定的狀態
			toggleSettingGroup('#showDigitalTime', ['#hourColor', '#colonColor', '#minuteColor', '#secondColor', '#showAmPm', '#amPmColor'], true); // 數位時間的子設定
			toggleSettingGroup('#showLunarDate', ['#showMinguoYear', '#minguoYearColor', '#showLunarMonth', '#lunarMonthColor', '#showLunarDay', '#lunarDayColor', '#showLunarShiChen', '#lunarShiChenColor', '#showJieqi', '#jieqiColor', '#showHolidays', '#holidayColor'], true); // 農曆的子設定
			toggleSettingGroup('#showAnalogClock', ['#hourHandColor', '#minuteHandColor', '#secondHandColor', '#tickColor', '#numberColor'], true); // 類比時鐘的子設定
			toggleSettingGroup('#showAnalogCalendar', ['#calendarHeaderColor', '#calendarWeekdayColor', '#calendarDayColor', '#calendarLunarColor'], true); // 類比日曆的子設定
			toggleSettingGroup('#showGregorianDate', ['#showGregorianYear', '#gregorianYearColor', '#showGregorianMonth', '#gregorianMonthColor', '#showGregorianDay', '#gregorianDayColor', '#showGregorianWeekday', '#gregorianWeekdayColor'], true); // 公曆的子設定
			toggleSettingGroup('#showGregorianDate', ['#showWeather'], true); // 天氣依賴於公曆
			const areWeatherChildrenEnabled = isGregorianOn && isWeatherOn; // 天氣子項目的啟用條件
			const locationItem = qs('#showWeatherLocation').closest('.setting-item'); // 獲取天氣地點設定項
			if (locationItem) { locationItem.classList.toggle('disabled', !areWeatherChildrenEnabled); locationItem.querySelectorAll('input, select, button').forEach(ctrl => ctrl.disabled = !areWeatherChildrenEnabled); } // 設定天氣地點的啟用/禁用
			const areLocationChildrenEnabled = isGregorianOn && isWeatherOn && isWeatherLocationOn; // 地點選擇器的啟用條件
			const selectorsItem = qs('#countySelect').closest('.setting-item'); // 獲取地點選擇器設定項
			if (selectorsItem) { selectorsItem.classList.toggle('disabled', !areLocationChildrenEnabled); selectorsItem.querySelectorAll('input, select, button').forEach(ctrl => ctrl.disabled = !areLocationChildrenEnabled); } // 設定地點選擇器的啟用/禁用
			const weatherColorPicker = qs('#weatherColor'); // 獲取天氣顏色選擇器
			if (weatherColorPicker) { weatherColorPicker.disabled = !areWeatherChildrenEnabled; const randomBtn = weatherColorPicker.nextElementSibling; if(randomBtn) randomBtn.disabled = weatherColorPicker.disabled; } // 設定天氣顏色的啟用/禁用
			const locationColorPicker = qs('#weatherLocationColor'); // 獲取地點顏色選擇器
			if (locationColorPicker) { locationColorPicker.disabled = !areLocationChildrenEnabled || !isWeatherLocationOn; const randomBtn = locationColorPicker.nextElementSibling; if(randomBtn) randomBtn.disabled = locationColorPicker.disabled; } // 設定地點顏色的啟用/禁用
			const movementItem = qs('#enableMovement').closest('.setting-item'); // 獲取移動設定項
			if (movementItem) { const isDisabled = settings.editMode; movementItem.classList.toggle('disabled', isDisabled); movementItem.querySelectorAll('input, select, button').forEach(ctrl => ctrl.disabled = isDisabled); } // 在編輯模式下禁用移動設定
			const itemsToUpdate = [ // 定義需要根據其對應開關狀態更新的顏色選擇器
				{ switchId: 'showAmPm', colorId: 'amPmColor' }, { switchId: 'showGregorianYear', colorId: 'gregorianYearColor' },
				{ switchId: 'showGregorianMonth', colorId: 'gregorianMonthColor' }, { switchId: 'showGregorianDay', colorId: 'gregorianDayColor' },
				{ switchId: 'showGregorianWeekday', colorId: 'gregorianWeekdayColor' }, { switchId: 'showMinguoYear', colorId: 'minguoYearColor' },
				{ switchId: 'showLunarMonth', colorId: 'lunarMonthColor' }, { switchId: 'showLunarDay', colorId: 'lunarDayColor' },
				{ switchId: 'showLunarShiChen', colorId: 'lunarShiChenColor' }, { switchId: 'showJieqi', colorId: 'jieqiColor' },
				{ switchId: 'showHolidays', colorId: 'holidayColor' },
			];
			itemsToUpdate.forEach(({ switchId, colorId }) => { // 遍歷並更新這些顏色選擇器的狀態
				const switchEl = qs(`#${switchId}`), colorEl = qs(`#${colorId}`); // 獲取開關和顏色選擇器元素
				if (switchEl && colorEl && !switchEl.checked) { // 如果開關存在且未被選中
					colorEl.disabled = true; // 禁用顏色選擇器
					const randomBtn = colorEl.nextElementSibling; // 獲取隨機顏色按鈕
					if (randomBtn && randomBtn.classList.contains('random-color-btn')) randomBtn.disabled = true; // 禁用隨機顏色按鈕
				}
			});
		}
		function updateWidgetVisibility() { // 根據設定顯示或隱藏各個元件
			setStyle(qs('#digital-widget'), { display: settings.showDigitalTime ? 'inline-flex' : 'none' }); // 數位時間
			setStyle(qs('#gregorian-date-widget'), { display: settings.showGregorianDate ? 'inline-flex' : 'none' }); // 公曆日期
			setStyle(qs('#lunar-date-widget'), { display: settings.showLunarDate ? 'inline-flex' : 'none' }); // 農曆日期
			setStyle(qs('#analog-clock-widget'), { display: settings.showAnalogClock ? 'inline-flex' : 'none' }); // 類比時鐘
			setStyle(qs('#analog-calendar-widget'), { display: settings.showAnalogCalendar ? 'inline-flex' : 'none' }); // 類比日曆
		}
		function s2t(input) { if (typeof input !== 'string' && !Array.isArray(input)) return input; const map = {'见':'見','贵':'貴','无':'無','开':'開','纳':'納','财':'財','挂':'掛','梁':'樑','动':'動','种':'種','启':'啟','钻':'鑽','订':'訂','竖':'豎','门':'門','词':'詞','讼':'訟','发':'髮','养':'養','马':'馬','经':'經','络':'絡','盖':'蓋','会':'會','学':'學','艺':'藝','医':'醫','装':'裝','结':'結','网':'網','渔':'漁','猎':'獵','亲':'親','进':'進','扫':'掃','绘':'繪','齐':'齊','斋':'齋','庙':'廟','灶':'竈','谢':'謝','问':'問','婿':'壻','归':'歸','宁':'寧','坟':'墳','寿':'壽','坏':'壞','补':'補','厕':'廁','仓':'倉','涂':'塗','桥':'橋','筑':'築','饰':'飾','墙':'牆','买':'買','车':'車','产':'產','雇':'僱','佣':'傭','货':'貨','机':'機','械':'械','酝':'醞','酿':'釀','铸':'鑄','针':'針','库':'庫','疗':'療','诸':'諸','馀':'餘','丧':'喪','断':'斷','蚁':'蟻','户':'戶','炉':'爐','栖':'棲','厨':'廚','胜':'勝','负':'負','灭':'滅','龙':'龍','鸡':'雞','猪':'豬','乌':'烏','双':'雙','宫':'宮','惊':'驚','蛰':'蟄','满':'滿','处':'處','时':'時','气':'氣','后':'後','灾':'災','复':'復','虚':'虛','贼':'賊','败':'敗','仪':'儀','祸':'禍','临':'臨','阴':'陰','阳':'陽','圣':'聖','冲':'沖','绝':'絕','岁':'歲','伤':'傷','杀':'殺','黄':'黃','节':'節','树':'樹','国':'國','万':'萬','长':'長','华':'華','为':'為','电':'電','声':'聲','冻':'凍','虫':'蟲','鱼':'魚','鹰':'鷹','来':'來','润':'潤','凉':'涼','麦':'麥','温':'溫','收':'收','闭':'閉','闰':'閏','谷':'穀','殓':'殮'}; const convert = (str) => str.split('').map(char => map[char] || char).join(''); return Array.isArray(input) ? input.map(convert) : convert(input); } // 簡體中文轉繁體中文的函式
		const moonPhaseData = { 1: { name: '朔月', aka: '新月', desc: '月球位於太陽和地球之間，月球的黑暗面朝向地球，因此我們看不見月亮。這是農曆月的開始。' }, 2: { name: '既朔月', desc: '新月之後，月球被太陽照亮的一小部分開始可見，呈現極細的彎月。' }, 3: { name: '蛾眉新月', desc: '月牙兒逐漸變寬，形如美女的秀眉。' }, 4: { name: '蛾眉月', desc: '月相持續變寬，更易於觀察。' }, 5: { name: '蛾眉月', desc: '月相持續變寬，更易於觀察。' }, 6: { name: '夕月', desc: '日落後不久即可在西方天空看到，故名夕月。' }, 7: { name: '上弦月', desc: '月球運行到其軌道的四分之一處，我們能看到月球被太陽照亮的一半，看起來像一個字母 "D"。' }, 8: { name: '上弦月', desc: '月球運行到其軌道的四分之一處，我們能看到月球被太陽照亮的一半，看起來像一個字母 "D"。' }, 9: { name: '九夜月', desc: '上弦月之後，可見的被照亮部分繼續增加。' }, 10: { name: '宵月', desc: '夜晚大部分時間都能看到月亮。' }, 11: { name: '漸盈凸月', desc: '月相接近圓滿，但尚未完全變圓。' }, 12: { name: '漸盈凸月', desc: '月相接近圓滿，但尚未完全變圓。' }, 13: { name: '漸盈凸月', desc: '月相接近圓滿，但尚未完全變圓。' }, 14: { name: '小望月', desc: '距離滿月僅一步之遙，非常明亮。' }, 15: { name: '望月', aka: '滿月', desc: '地球位於太陽和月球之間，月球被太陽照亮的整個半球都朝向地球，看起來是一個完整的圓盤。' }, 16: { name: '既望月', desc: '滿月之後，月亮開始由盈轉虧。' }, 17: { name: '立待月', desc: '月出時間稍晚，需要站著等待一會兒。' }, 18: { name: '居待月', desc: '月出更晚，可以在家中坐著等待。' }, 19: { name: '寢待月', desc: '月亮升起時已近睡覺時間。' }, 20: { name: '更待月', desc: '月亮在深夜一更之後才升起。' }, 21: { name: '漸虧凸月', desc: '可見的被照亮部分開始減少，但仍然大於一半。' }, 22: { name: '下弦月', desc: '我們再次看到月球被照亮的一半，但這次看起來像一個反向的 "D"。' }, 23: { name: '下弦月', desc: '我們再次看到月球被照亮的一半，但這次看起來像一個反向的 "D"。' }, 24: { name: '有明月', desc: '天將亮時，仍可在天空中看見月亮。' }, 25: { name: '蛾眉殘月', desc: '月相變回彎曲的鐮刀形狀。' }, 26: { name: '蛾眉殘月', desc: '月相變回彎曲的鐮刀形狀。' }, 27: { name: '殘月', desc: '月牙兒變得更細。' }, 28: { name: '殘月', desc: '月牙兒變得更細。' }, 29: { name: '曉月', desc: '僅在黎明前的東方天空短暫可見。' }, 30: { name: '晦月', desc: '月亮完全消失在太陽的光芒中，為一個農曆月的結束。' } }; // 月相資料物件
		function getMoonPhaseDetails(lunarDay) { return moonPhaseData[lunarDay] || { name: '未知月相', desc: '無此月相的詳細資訊。' }; } // 根據農曆日期獲取月相詳情
		function getMoonPhaseSVG(lunarDay, size = '1em') { const phase = (lunarDay - 1) / 29.0, r = 50, cx = 50, cy = 50, light = '#f0e68c', dark = '#222'; const cos_angle = Math.cos(phase * 2 * Math.PI + Math.PI); const base = phase > 0.5 ? `<rect x="0" y="0" width="${cx}" height="${r*2}" fill="${light}" /><rect x="${cx}" y="0" width="${cx}" height="${r*2}" fill="${dark}" />` : `<rect x="0" y="0" width="${cx}" height="${r*2}" fill="${dark}" /><rect x="${cx}" y="0" width="${cx}" height="${r*2}" fill="${light}" />`; const terminator = `<ellipse cx="${cx}" cy="${cy}" rx="${r * Math.abs(cos_angle)}" ry="${r}" fill="${cos_angle > 0 ? light : dark}" />`; const id = 'moon-clip-' + Math.random().toString(36).substr(2, 9); return `<svg width="${size}" height="${size}" viewBox="0 0 100 100" style="display: inline-block; vertical-align: middle; border-radius: 50%; box-shadow: 0 0 2px rgba(240, 230, 140, 0.5);"><defs><clipPath id="${id}"><circle cx="${cx}" cy="${cy}" r="${r}" /></clipPath></defs><g clip-path="url(#${id})">${base}${terminator}</g></svg>`; } // 根據農曆日期生成月相的 SVG 圖示
		function getJieqiDescription(name) { const d = { '立春': '春季開始，萬物復甦。', '雨水': '降雨增多，春耕開始。', '驚蟄': '春雷響動，驚醒冬眠動物。', '春分': '晝夜等長，春意盎然。', '清明': '氣候清爽明朗，掃墓祭祖。', '穀雨': '雨水滋潤，穀物生長。', '立夏': '夏季開始，萬物繁茂。', '小滿': '夏熟作物籽粒開始飽滿。', '芒種': '收穫與播種的時節。', '夏至': '北半球白晝最長，盛夏開始。', '小暑': '天氣開始炎熱。', '大暑': '一年中最炎熱的時期。', '立秋': '秋季開始，氣溫漸降。', '處暑': '暑氣漸退，天氣轉涼。', '白露': '水氣凝結成露，天氣漸寒。', '秋分': '晝夜等長，秋高氣爽。', '寒露': '氣溫更低，天氣轉冷。', '霜降': '天氣漸冷，露水凝結成霜。', '立冬': '冬季開始，萬物收藏。', '小雪': '開始降雪，但雪量不大。', '大雪': '降雪量增多，天氣更冷。', '冬至': '北半球白晝最短，數九寒天開始。', '小寒': '天氣寒冷，尚未達到最冷。', '大寒': '一年中最寒冷的時期。' }; return d[name] || '此節氣無詳細說明。'; } // 獲取節氣的描述文字
		function checkYearlyCache(year) { if (state.yearlyDataCache.year !== year) state.yearlyDataCache = { year: year, holidays: [], jieqi: [] }; } // 檢查並在需要時重設年度資料快取
		function getHolidaysForYear(year) { checkYearlyCache(year); if (state.yearlyDataCache.holidays.length > 0) return state.yearlyDataCache.holidays; const holidays = []; [{ n: '元旦', m: 0, d: 1 }, { n: '和平紀念日', m: 1, d: 28 }, { n: '兒童節', m: 3, d: 4 }, { n: '勞動節', m: 4, d: 1 }, { n: '國慶日', m: 9, d: 10 }, { n: '聖誕節', m: 11, d: 25 }].forEach(h => holidays.push({ name: h.n, date: new Date(year, h.m, h.d) })); [{m:1,d:1,n:'農曆新年'}, {m:1,d:15,n:'元宵節'}, {m:5,d:5,n:'端午節'}, {m:7,d:7,n:'七夕'}, {m:7,d:15,n:'中元節'}, {m:8,d:15,n:'中秋節'}, {m:9,d:9,n:'重陽節'}, {m:12,d:8,n:'臘八節'}].forEach(lh => { const sd = Lunar.fromYmd(year, lh.m, lh.d).getSolar(); holidays.push({ name: lh.n, date: new Date(sd.getYear(), sd.getMonth() - 1, sd.getDay()) }); }); const nySolar = Lunar.fromYmd(year, 1, 1).getSolar(); holidays.push({ name: '除夕', date: new Date(nySolar.getYear(), nySolar.getMonth() - 1, nySolar.getDay() - 1) }); const qmJieqi = getJieqiForYear(year).find(jq => jq.name === '清明'); if(qmJieqi) holidays.push({ name: '清明節', date: qmJieqi.date }); const may1 = new Date(year, 4, 1); holidays.push({ name: '母親節', date: new Date(year, 4, 1 + (7 - may1.getDay() + 7) % 7 + 7) }); return state.yearlyDataCache.holidays = holidays.sort((a, b) => a.date - b.date); } // 獲取指定年份的所有節假日
		function getJieqiForYear(year) { checkYearlyCache(year); if (state.yearlyDataCache.jieqi.length > 0) return state.yearlyDataCache.jieqi; const pinyinMap = { 'LI_CHUN': '立春', 'YU_SHUI': '雨水', 'JING_ZHE': '驚蟄', 'CHUN_FEN': '春分', 'QING_MING': '清明', 'GU_YU': '穀雨', 'LI_XIA': '立夏', 'XIAO_MAN': '小滿', 'MANG_ZHONG': '芒種', 'XIA_ZHHI': '夏至', 'XIAO_SHU': '小暑', 'DA_SHU': '大暑', 'LI_QIU': '立秋', 'CHU_SHU': '處暑', 'BAI_LU': '白露', 'QIU_FEN': '秋分', 'HAN_LU': '寒露', 'SHUANG_JIANG': '霜降', 'LI_DONG': '立冬', 'XIAO_XUE': '小雪', 'DA_XUE': '大雪', 'DONG_ZHI': '冬至', 'XIAO_HAN': '小寒', 'DA_HAN': '大寒' }; const sMap = { '惊蛰': '驚蟄', '小满': '小滿', '芒种': '芒種', '处暑': '處暑', '谷雨': '穀雨' }; const table = Lunar.fromYmd(year, 1, 1).getJieQiTable(); return state.yearlyDataCache.jieqi = Object.entries(table).map(([name, dateStr]) => ({ name: pinyinMap[name] || sMap[name] || name, date: new Date(dateStr) })).sort((a, b) => a.date - b.date); } // 獲取指定年份的所有節氣
		const timeInfoByHour = { 0: { shichen: '子', period: '凌晨' }, 1: { shichen: '丑', period: '凌晨' }, 2: { shichen: '丑', period: '凌晨' }, 3: { shichen: '寅', period: '凌晨' }, 4: { shichen: '寅', period: '凌晨' }, 5: { shichen: '卯', period: '清晨' }, 6: { shichen: '卯', period: '清晨' }, 7: { shichen: '辰', period: '清晨' }, 8: { shichen: '辰', period: '清晨' }, 9: { shichen: '巳', period: '上午' }, 10: { shichen: '巳', period: '上午' }, 11: { shichen: '午', period: '上午' }, 12: { shichen: '午', period: '中午' }, 13: { shichen: '未', period: '下午' }, 14: { shichen: '未', period: '下午' }, 15: { shichen: '申', period: '下午' }, 16: { shichen: '申', period: '下午' }, 17: { shichen: '酉', period: '傍晚' }, 18: { shichen: '酉', period: '傍晚' }, 19: { shichen: '戌', period: '夜晚' }, 20: { shichen: '戌', period: '夜晚' }, 21: { shichen: '亥', period: '夜晚' }, 22: { shichen: '亥', period: '夜晚' }, 23: { shichen: '子', period: '深夜' } }; // 小時對應的時辰和時段
		const shichenTimeRanges = { '子': '23:00 - 00:59', '丑': '01:00 - 02:59', '寅': '03:00 - 04:59', '卯': '05:00 - 06:59', '辰': '07:00 - 08:59', '巳': '09:00 - 10:59', '午': '11:00 - 12:59', '未': '13:00 - 14:59', '申': '15:00 - 16:59', '酉': '17:00 - 18:59', '戌': '19:00 - 20:59', '亥': '21:00 - 22:59' }; // 各時辰的時間範圍
		const getShiChen = (h) => timeInfoByHour[h]?.shichen || ''; // 根據小時獲取時辰
		const getShiChenTimeRange = (name) => shichenTimeRanges[name] || ''; // 根據時辰名稱獲取時間範圍
		const getDetailedTimePeriod = (h) => timeInfoByHour[h]?.period || ''; // 根據小時獲取詳細時段 (凌晨、上午等)
		function getWeatherDescriptionAndEmoji(code) { const map = { 0: { desc: '晴' }, 1: { desc: '多雲時晴' }, 2: { desc: '局部多雲' }, 3: { desc: '陰' }, 45: { desc: '霧' }, 48: { desc: '凍霧' }, 51: { desc: '毛毛雨' }, 53: { desc: '毛毛雨' }, 55: { desc: '毛毛雨' }, 56: { desc: '凍毛毛雨' }, 57: { desc: '凍毛毛雨' }, 61: { desc: '雨' }, 63: { desc: '雨' }, 65: { desc: '大雨' }, 66: { desc: '凍雨' }, 67: { desc: '凍雨' }, 71: { desc: '雪' }, 73: { desc: '雪' }, 75: { desc: '大雪' }, 77: { desc: '冰雹' }, 80: { desc: '陣雨' }, 81: { desc: '陣雨' }, 82: { desc: '大陣雨' }, 85: { desc: '陣雪' }, 86: { desc: '大陣雪' }, 95: { desc: '雷陣雨' }, 96: { desc: '雷陣雨伴冰雹' }, 99: { desc: '雷陣雨伴冰雹' } }; return map[code] || { desc: '未知' }; } // 根據天氣代碼獲取天氣描述
		function getWeatherSVGIcon(code, size = '1em') { const createSvg = (viewBox = "0 0 64 64") => `<svg width="${size}" height="${size}" viewBox="${viewBox}" class="weather-svg-icon">`; const sun = () => `${createSvg()}<g><circle cx="32" cy="32" r="14" fill="#FDB813" stroke="#FDB813" stroke-width="2"/><g stroke="#FDB813" stroke-width="3" stroke-linecap="round">${[0, 45, 90, 135, 180, 225, 270, 315].map(a => `<line x1="32" y1="15" x2="32" y2="5" transform="rotate(${a} 32 32)"/>`).join('')}</g></g></svg>`; const cloud = () => `${createSvg()}<g><path d="M 15,42 A 10,10 0 0 1 25,32 A 18,18 0 0 1 52,35 A 12,12 0 0 1 58,48 L 20,48 A 10,10 0 0 1 15,42 Z" fill="#B0C4DE" stroke="#90a4be" stroke-width="1.5"/></g></svg>`; const partlyCloudy = () => `${createSvg()}<g><circle cx="24" cy="24" r="12" fill="#FDB813"/><path d="M 15,42 A 10,10 0 0 1 25,32 A 18,18 0 0 1 52,35 A 12,12 0 0 1 58,48 L 20,48 A 10,10 0 0 1 15,42 Z" fill="#B0C4DE" stroke="#90a4be" stroke-width="1.5"/></g></svg>`; const rain = () => `${createSvg()}<g><path d="M 15,38 A 10,10 0 0 1 25,28 A 18,18 0 0 1 52,31 A 12,12 0 0 1 58,44 L 20,44 A 10,10 0 0 1 15,38 Z" fill="#90a4be" stroke="#70849e" stroke-width="1.5"/><g stroke="#4682B4" stroke-width="3" stroke-linecap="round">${[[25,48,25,58],[37,50,37,60],[49,48,49,58]].map(c => `<line x1="${c[0]}" y1="${c[1]}" x2="${c[2]}" y2="${c[3]}"/>`).join('')}</g></g></svg>`; const snow = () => `${createSvg()}<g><path d="M 15,38 A 10,10 0 0 1 25,28 A 18,18 0 0 1 52,31 A 12,12 0 0 1 58,44 L 20,44 A 10,10 0 0 1 15,38 Z" fill="#B0C4DE" stroke="#90a4be" stroke-width="1.5"/><g stroke="#FFFFFF" stroke-width="2" stroke-linecap="round">${[[25,55],[37,58],[49,55]].map(c => `<path d="M${c[0]-4},${c[1]} l8,0 M${c[0]},${c[1]-4} l0,8 M${c[0]-3},${c[1]-3} l6,6 M${c[0]-3},${c[1]+3} l6,-6"/>`).join('')}</g></g></svg>`; const storm = () => `${createSvg()}<g><path d="M 15,38 A 10,10 0 0 1 25,28 A 18,18 0 0 1 52,31 A 12,12 0 0 1 58,44 L 20,44 A 10,10 0 0 1 15,38 Z" fill="#6c757d" stroke="#5c656d" stroke-width="1.5"/><path d="M 38,45 L 32,55 L 42,55 L 36,65" fill="none" stroke="#FFC107" stroke-width="3" stroke-linejoin="round" stroke-linecap="round"/></g></svg>`; const fog = () => `${createSvg()}<g><path d="M 15,42 A 10,10 0 0 1 25,32 A 18,18 0 0 1 52,35 A 12,12 0 0 1 58,48 L 20,48 A 10,10 0 0 1 15,42 Z" fill="#E0E0E0" stroke="#C0C0C0" stroke-width="1.5"/><g stroke="#B0B0B0" stroke-width="3" stroke-linecap="round">${[[18,38,56,38],[22,44,52,44],[20,50,54,50]].map(c => `<line x1="${c[0]}" y1="${c[1]}" x2="${c[2]}" y2="${c[3]}"/>`).join('')}</g></g></svg>`; switch (code) { case 0: return sun(); case 1: return partlyCloudy(); case 2: case 3: return cloud(); case 45: case 48: return fog(); case 51: case 53: case 55: case 61: case 63: case 80: case 81: return rain(); case 65: case 82: return rain(); case 95: case 96: case 99: return storm(); case 56: case 57: case 66: case 67: case 71: case 73: case 75: case 77: case 85: case 86: return snow(); default: return `<span style="font-size:${size}; vertical-align: middle;">❓</span>`; } } // 根據天氣代碼獲取天氣的 SVG 圖示
		const zodiacSVGFunctions = { "鼠": (s) => `<svg class="zodiac-svg-icon" width="${s}" height="${s}" viewBox="0 0 100 100"><path d="M 50 90 C 20 90, 20 40, 50 30 C 80 40, 80 90, 50 90 Z" fill="#9E9E9E" stroke="#616161" stroke-width="2"></path><path d="M 25 45 A 15 15 0 1 1 35 30" fill="#757575" stroke="#616161" stroke-width="2"></path><path d="M 75 45 A 15 15 0 1 0 65 30" fill="#757575" stroke="#616161" stroke-width="2"></path><path d="M 40 60 a 3 3 0 1 1 0.1 0" fill="black"></path><path d="M 60 60 a 3 3 0 1 1 0.1 0" fill="black"></path><path d="M 50 75 a 4 4 0 1 1 0.1 0" fill="black"></path></svg>`, "牛": (s) => `<svg class="zodiac-svg-icon" width="${s}" height="${s}" viewBox="0 0 100 100"><path d="M 30 30 Q 10 10 20 40" fill="#795548" stroke="#4E342E" stroke-width="2"></path><path d="M 70 30 Q 90 10 80 40" fill="#795548" stroke="#4E342E" stroke-width="2"></path><path d="M 50 95 C 20 95, 25 30, 50 25 C 75 30, 80 95, 50 95 Z" fill="#795548" stroke="#4E342E" stroke-width="2"></path><path d="M 25 50 L 15 60 L 30 60 Z" fill="#A1887F" stroke="#4E342E" stroke-width="2"></path><path d="M 75 50 L 85 60 L 70 60 Z" fill="#A1887F" stroke="#4E342E" stroke-width="2"></path><path d="M 40 60 a 3 3 0 1 1 0.1 0" fill="black"></path><path d="M 60 60 a 3 3 0 1 1 0.1 0" fill="black"></path><path d="M 40 80 A 10 8 0 1 1 60 80" fill="#A1887F" stroke="#4E342E" stroke-width="2"></path></svg>`, "虎": (s) => `<svg class="zodiac-svg-icon" width="${s}" height="${s}" viewBox="0 0 100 100"><path d="M 50 90 A 40 40 0 1 1 50.1 90 Z" fill="#FF9800" stroke="#E65100" stroke-width="2"></path><path d="M 25 30 A 10 10 0 1 1 35 20" fill="#F57C00" stroke="#E65100" stroke-width="2"></path><path d="M 75 30 A 10 10 0 1 0 65 20" fill="#F57C00" stroke="#E65100" stroke-width="2"></path><path d="M 20 50 L 30 55" stroke="black" stroke-width="3" fill="none"></path><path d="M 22 65 L 32 68" stroke="black" stroke-width="3" fill="none"></path><path d="M 80 50 L 70 55" stroke="black" stroke-width="3" fill="none"></path><path d="M 78 65 L 68 68" stroke="black" stroke-width="3" fill="none"></path><path d="M 50 30 L 50 40" stroke="black" stroke-width="3" fill="none"></path><path d="M 40 55 a 3 3 0 1 1 0.1 0" fill="black"></path><path d="M 60 55 a 3 3 0 1 1 0.1 0" fill="black"></path><path d="M 50 70 L 45 80 L 55 80 Z" fill="black"></path></svg>`, "兔": (s) => `<svg class="zodiac-svg-icon" width="${s}" height="${s}" viewBox="0 0 100 100"><path d="M 35 40 C 30 10, 40 10, 40 40 Z" fill="#FAFAFA" stroke="#BDBDBD" stroke-width="2"></path><path d="M 65 40 C 70 10, 60 10, 60 40 Z" fill="#FAFAFA" stroke="#BDBDBD" stroke-width="2"></path><path d="M 50 90 A 25 30 0 1 1 50.1 90 Z" fill="#FAFAFA" stroke="#BDBDBD" stroke-width="2"></path><path d="M 42 65 a 3 3 0 1 1 0.1 0" fill="#F44336"></path><path d="M 58 65 a 3 3 0 1 1 0.1 0" fill="#F44336"></path><path d="M 50 75 L 50 80 M 45 80 Q 50 85 55 80" fill="none" stroke="#BDBDBD" stroke-width="2"></path></svg>`, "龍": (s) => `<svg class="zodiac-svg-icon" width="${s}" height="${s}" viewBox="0 0 100 100"><path d="M 50 95 C 20 95, 15 40, 50 20 C 85 40, 80 95, 50 95 Z" fill="#00695C" stroke="#004D40" stroke-width="2"></path><path d="M 35 30 C 20 10, 40 15, 40 35" fill="#FFC107" stroke="#FF8F00" stroke-width="1"></path><path d="M 65 30 C 80 10, 60 15, 60 35" fill="#FFC107" stroke="#FF8F00" stroke-width="1"></path><path d="M 40 80 C 35 70, 65 70, 60 80 Q 50 90 40 80 Z" fill="#00695C" stroke="#004D40" stroke-width="2"></path><circle cx="40" cy="55" r="4" fill="#F44336"></circle><circle cx="60" cy="55" r="4" fill="#F44336"></circle><path d="M 35 80 Q 15 75 30 65" fill="none" stroke="#FF8F00" stroke-width="1"></path><path d="M 65 80 Q 85 75 70 65" fill="none" stroke="#FF8F00" stroke-width="1"></path></svg>`, "蛇": (s) => `<svg class="zodiac-svg-icon" width="${s}" height="${s}" viewBox="0 0 100 100"><path d="M 50 20 C 80 20, 80 70, 50 90 C 20 70, 20 20, 50 20 Z" fill="#8BC34A" stroke="#558B2F" stroke-width="2"></path><path d="M 40 50 a 3 3 0 1 1 0.1 0" fill="black"></path><path d="M 60 50 a 3 3 0 1 1 0.1 0" fill="black"></path><path d="M 50 90 L 50 98 L 47 95 M 50 98 L 53 95" stroke="#F44336" stroke-width="2" fill="none"></path></svg>`, "馬": (s) => `<svg class="zodiac-svg-icon" width="${s}" height="${s}" viewBox="0 0 100 100"><path d="M 60 10 L 55 40 L 65 40 L 60 60" fill="#6D4C41" stroke="#5D4037" stroke-width="2"></path><path d="M 50 95 C 25 95, 30 20, 50 20 C 70 20, 75 95, 50 95 Z" fill="#A1887F" stroke="#5D4037" stroke-width="2"></path><path d="M 35 30 L 30 15 L 45 30 Z" fill="#A1887F" stroke="#5D4037" stroke-width="2"></path><path d="M 65 30 L 70 15 L 55 30 Z" fill="#A1887F" stroke="#5D4037" stroke-width="2"></path><path d="M 40 55 a 3 3 0 1 1 0.1 0" fill="black"></path><path d="M 60 55 a 3 3 0 1 1 0.1 0" fill="black"></path></svg>`, "羊": (s) => `<svg class="zodiac-svg-icon" width="${s}" height="${s}" viewBox="0 0 100 100"><circle cx="50" cy="40" r="20" fill="#ECEFF1" stroke="#B0BEC5" stroke-width="1"></circle><circle cx="35" cy="55" r="18" fill="#ECEFF1" stroke="#B0BEC5" stroke-width="1"></circle><circle cx="65" cy="55" r="18" fill="#ECEFF1" stroke="#B0BEC5" stroke-width="1"></circle><circle cx="50" cy="65" r="20" fill="#ECEFF1" stroke="#B0BEC5" stroke-width="1"></circle><circle cx="50" cy="65" r="15" fill="#CFD8DC" stroke="#78909C" stroke-width="2"></circle><circle cx="44" cy="62" r="2.5" fill="black"></circle><circle cx="56" cy="62" r="2.5" fill="black"></circle><path d="M 30 50 C 15 45, 15 65, 30 65" fill="none" stroke="#78909C" stroke-width="2"></path><path d="M 70 50 C 85 45, 85 65, 70 65" fill="none" stroke="#78909C" stroke-width="2"></path></svg>`, "猴": (s) => `<svg class="zodiac-svg-icon" width="${s}" height="${s}" viewBox="0 0 100 100"><path d="M 20 60 A 15 15 0 1 1 20.1 60 Z" fill="#BCAAA4" stroke="#795548" stroke-width="2"></path><path d="M 80 60 A 15 15 0 1 1 80.1 60 Z" fill="#BCAAA4" stroke="#795548" stroke-width="2"></path><path d="M 50 90 A 35 35 0 1 1 50.1 90 Z" fill="#BCAAA4" stroke="#795548" stroke-width="2"></path><path d="M 50 80 A 25 25 0 1 1 50.1 80 Z" fill="#D7CCC8" stroke="#795548" stroke-width="2"></path><path d="M 40 60 a 3 3 0 1 1 0.1 0" fill="black"></path><path d="M 60 60 a 3 3 0 1 1 0.1 0" fill="black"></path><path d="M 40 75 Q 50 85 60 75" fill="none" stroke="#795548" stroke-width="2"></path></svg>`, "雞": (s) => `<svg class="zodiac-svg-icon" width="${s}" height="${s}" viewBox="0 0 100 100"><circle cx="50" cy="60" r="25" fill="#FFFFFF" stroke="#9E9E9E" stroke-width="2"></circle><path d="M 40 35 Q 45 25, 50 35 T 60 35" fill="#F44336" stroke="#D32F2F" stroke-width="1"></path><path d="M 75 60 L 85 65 L 75 70 Z" fill="#FFC107" stroke="#FFA000"></path><path d="M 70 75 A 5 8 0 1 1 70.1 75 Z" fill="#F44336" stroke="#D32F2F" stroke-width="1"></path><circle cx="60" cy="55" r="3" fill="black"></circle></svg>`, "狗": (s) => `<svg class="zodiac-svg-icon" width="${s}" height="${s}" viewBox="0 0 100 100"><path d="M 25 40 L 15 70 L 35 50 Z" fill="#FFE0B2" stroke="#FB8C00" stroke-width="2"></path><path d="M 75 40 L 85 70 L 65 50 Z" fill="#FFE0B2" stroke="#FB8C00" stroke-width="2"></path><path d="M 50 90 C 20 90, 20 40, 50 35 C 80 40, 80 90, 50 90 Z" fill="#FFE0B2" stroke="#FB8C00" stroke-width="2"></path><path d="M 40 60 a 4 4 0 1 1 0.1 0" fill="black"></path><path d="M 60 60 a 4 4 0 1 1 0.1 0" fill="black"></path><path d="M 50 75 L 45 85 L 55 85 Z" fill="black"></path></svg>`, "豬": (s) => `<svg class="zodiac-svg-icon" width="${s}" height="${s}" viewBox="0 0 100 100"><path d="M 25 40 L 20 20 L 40 40 Z" fill="#F8BBD0" stroke="#EC407A" stroke-width="2"></path><path d="M 75 40 L 80 20 L 60 40 Z" fill="#F8BBD0" stroke="#EC407A" stroke-width="2"></path><path d="M 50 90 A 35 35 0 1 1 50.1 90 Z" fill="#F8BBD0" stroke="#EC407A" stroke-width="2"></path><path d="M 50 75 A 15 10 0 1 1 50.1 75 Z" fill="#F48FB1" stroke="#EC407A" stroke-width="2"></path><path d="M 46 75 a 2 2 0 1 1 0.1 0" fill="black"></path><path d="M 54 75 a 2 2 0 1 1 0.1 0" fill="black"></path><path d="M 40 52 a 3 3 0 1 1 0.1 0" fill="black"></path><path d="M 60 52 a 3 3 0 1 1 0.1 0" fill="black"></path></svg>` }; // 十二生肖的 SVG 圖示產生函式
		const getShengXiaoSVG = (name, size = '1.2em') => zodiacSVGFunctions[name] ? zodiacSVGFunctions[name](size) : ''; // 根據生肖名稱獲取對應的 SVG 圖示
		function addCalendarBgMonth(container, month) { // 在日曆容器中加入背景月份數字
			let bgMonthEl = container.querySelector('.calendar-bg-month'); // 尋找現有的背景月份元素
			if (!bgMonthEl) { bgMonthEl = document.createElement('div'); bgMonthEl.className = 'calendar-bg-month'; container.insertBefore(bgMonthEl, container.firstChild); } // 如果不存在，則創建一個新的並插入
			bgMonthEl.textContent = month; // 設定月份文字
		}
		function updateDigitalClock() { // 更新數位時鐘和所有日期資訊的顯示
			const now = new Date(); // 獲取目前時間
			const bg = qs('#background-scanline-overlay'), txt = qs('#text-scanline-overlay'); // 獲取掃描線圖層
			if (settings.enableBackgroundScanline) { bg.classList.toggle('pattern-a', state.scanlinePatternIsA); bg.classList.toggle('pattern-b', !state.scanlinePatternIsA); } // 切換背景掃描線樣式
			if (settings.enableTextScanline) { txt.classList.toggle('pattern-a', !state.scanlinePatternIsA); txt.classList.toggle('pattern-b', state.scanlinePatternIsA); } // 切換文字掃描線樣式
			if (settings.showDigitalTime) { // 如果設定顯示數位時間
				const parts = new Intl.DateTimeFormat('en-US', { hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: false }).formatToParts(now); // 格式化時間
				const h = parts.find(p => p.type === 'hour')?.value.padStart(2, '0') || '00'; // 獲取小時
				const m = parts.find(p => p.type === 'minute')?.value || '00'; // 獲取分鐘
				const s = parts.find(p => p.type === 'second')?.value || '00'; // 獲取秒數
				let displayHour = h, amPmText = ''; // 初始化顯示的小時和上下午文字
				if (settings.showAmPm) { const h12 = parseInt(h, 10); amPmText = getDetailedTimePeriod(h12); let dH12 = h12 % 12; if (dH12 === 0) dH12 = 12; displayHour = dH12.toString().padStart(2, '0'); } // 處理 12 小時制
				qs('#hoursDisplay').textContent = displayHour; qs('#minutesDisplay').textContent = m; qs('#secondsDisplay').textContent = s; qs('#amPmDisplay').textContent = amPmText; // 更新時間顯示
				setStyle(qs('#hoursDisplay'), { color: settings.hourColor }); setStyle(qs('#minutesDisplay'), { color: settings.minuteColor }); setStyle(qs('#colonDisplay'), { color: settings.colonColor }); setStyle(qs('#secondsDisplay'), { color: settings.secondColor }); setStyle(qs('#amPmDisplay'), { color: settings.amPmColor, display: amPmText ? 'block' : 'none' }); // 更新時間顏色
			}
			if (settings.showGregorianDate) { // 如果設定顯示公曆日期
				let gregorianParts = []; // 初始化公曆日期部分
				if (settings.showGregorianYear) gregorianParts.push(`<span class="gregorian-year-target" style="color: ${settings.gregorianYearColor};">${now.getFullYear()}年</span>`); // 加入年份
				if (settings.showGregorianMonth) gregorianParts.push(`<span class="gregorian-month-target" style="color: ${settings.gregorianMonthColor};">${(now.getMonth() + 1).toString().padStart(2, '0')}月</span>`); // 加入月份
				if (settings.showGregorianDay) gregorianParts.push(`<span class="gregorian-day-target" style="color: ${settings.gregorianDayColor};">${now.getDate().toString().padStart(2, '0')}日</span>`); // 加入日期
				if (settings.showGregorianWeekday) gregorianParts.push(`<span class="weekday-target" style="color: ${settings.gregorianWeekdayColor};">周${['日', '一', '二', '三', '四', '五', '六'][now.getDay()]}</span>`); // 加入星期
				qs('#gregorianDateParts').innerHTML = gregorianParts.join(''); // 更新公曆日期顯示
			}
			if (settings.showLunarDate) { // 如果設定顯示農曆日期
				let lunarParts = [], combinedJieqiHolidayText = ''; // 初始化農曆部分和節氣節日文字
				const currentYear = now.getFullYear(); // 獲取目前年份
				if (state.yearlyDataCache.year !== currentYear) { getHolidaysForYear(currentYear); getJieqiForYear(currentYear); } // 如果年份變更，則重新載入年度資料
				const solar = Solar.fromDate(now), lunar = solar.getLunar(); // 獲取農曆物件
				if (settings.showMinguoYear) { const shengxiao = s2t(lunar.getYearShengXiao()); lunarParts.push(`<span class="lunar-year-target" title="查看十二生肖" style="color: ${settings.minguoYearColor};">${now.getFullYear() - 1911}年${getShengXiaoSVG(shengxiao)}</span>`); } // 加入民國年和生肖
				if (settings.showLunarMonth) { const day = lunar.getDay(); const phase = getMoonPhaseDetails(day); const phaseName = phase.aka ? `${phase.name}(${phase.aka})` : phase.name; lunarParts.push(`<span class="lunar-month-target-group"><span class="lunar-month-text-target" title="查看月曆" style="color: ${settings.lunarMonthColor};">${s2t(lunar.getMonthInChinese())}</span><span class="moon-phase-icon-target" title="查看月相詳情: ${phaseName}" style="color: ${settings.lunarMonthColor};">${getMoonPhaseSVG(day, '1.1em')}</span></span>`); } // 加入農曆月份和月相
				if (settings.showLunarDay) lunarParts.push(`<span class="lunar-day-target" style="color: ${settings.lunarDayColor};">${s2t(lunar.getDayInChinese())}</span>`); // 加入農曆日期
				if (settings.showLunarShiChen) lunarParts.push(`<span class="lunar-shichen-target" style="color: ${settings.lunarShiChenColor};">${getShiChen(now.getHours())}時</span>`); // 加入時辰
				let jieQiText = '', holidayText = ''; // 初始化節氣和節日文字
				if (settings.showJieqi) { const jq = state.yearlyDataCache.jieqi.find(j => j.date.toDateString() === now.toDateString()) || state.yearlyDataCache.jieqi.find(j => j.date > now); if (jq) { const days = Math.ceil((jq.date - now) / 864e5); jieQiText = (days === 0) ? `${jq.name}` : `${days}➡${jq.name}`; } } // 獲取節氣資訊
				if (settings.showHolidays) { const h = state.yearlyDataCache.holidays.find(h => h.date.toDateString() === now.toDateString()) || state.yearlyDataCache.holidays.find(h => h.date > now); if (h) { const days = Math.ceil((h.date - now) / 864e5); holidayText = (days === 0) ? `${h.name}` : `${days}➡${h.name}`; } } // 獲取節日資訊
				let marqueeParts = []; // 初始化跑馬燈內容
				if(jieQiText) marqueeParts.push(`<span style="color: ${settings.jieqiColor};">${jieQiText}</span>`); // 加入節氣到跑馬燈
				if(holidayText) marqueeParts.push(`<span style="color: ${settings.holidayColor};">${holidayText}</span>`); // 加入節日到跑馬燈
				combinedJieqiHolidayText = marqueeParts.join(' '); // 組合跑馬燈文字
				qs('#lunarDateDisplay').innerHTML = lunarParts.join(''); // 更新農曆日期顯示
				setStyle(qs('#lunarDateDisplay'), { display: lunarParts.length > 0 ? 'inline-block' : 'none' }); // 根據內容決定是否顯示
				const jieqiMarqueeVisible = settings.showJieqi || settings.showHolidays; // 判斷節氣跑馬燈是否可見
				setStyle(qs('#jieqiHolidayMarqueeContainer'), { display: jieqiMarqueeVisible ? 'block' : 'none' }); // 設定節氣跑馬燈可見性
				if (jieqiMarqueeVisible && state.lastMarqueeContent !== combinedJieqiHolidayText) { updateMarquee(combinedJieqiHolidayText, 'jieqi'); state.lastMarqueeContent = combinedJieqiHolidayText; } // 如果內容更新，則更新跑馬燈
			}
			const weatherMarqueeVisible = settings.showWeather && settings.showGregorianDate; // 判斷天氣跑馬燈是否可見
			setStyle(qs('#weatherMarqueeContainer'), { display: weatherMarqueeVisible ? 'block' : 'none' }); // 設定天氣跑馬燈可見性
			if (weatherMarqueeVisible && state.lastWeatherContent && qs('#weatherMarqueeInner .weather-marquee-content').innerHTML !== state.lastWeatherContent) { updateMarquee(state.lastWeatherContent, 'weather'); } // 如果內容更新，則更新跑馬燈
		}
		function updateMarquee(text, type) { // 更新跑馬燈內容和動畫
			const isWeather = type === 'weather'; // 判斷跑馬燈類型
			const ids = { container: isWeather ? 'weatherMarqueeContainer' : 'jieqiHolidayMarqueeContainer', inner: isWeather ? 'weatherMarqueeInner' : 'jieqiHolidayMarqueeInner' }; // 根據類型獲取 ID
			const classes = { content: isWeather ? 'weather-marquee-content' : 'jieqi-holiday-marquee-content', duplicate: isWeather ? 'weather-marquee-content-duplicate' : 'jieqi-holiday-marquee-content-duplicate' }; // 根據類型獲取 class
			const container = qs(`#${ids.container}`), inner = qs(`#${ids.inner}`); // 獲取容器和內部元素
			if (!container || !inner) return; // 如果元素不存在則返回
			const contentSpan = inner.querySelector(`.${classes.content}`), duplicateSpan = inner.querySelector(`.${classes.duplicate}`); // 獲取內容和複製內容的 span
			if (!contentSpan || !duplicateSpan) return; // 如果 span 不存在則返回
			contentSpan.innerHTML = text; // 設定內容
			requestAnimationFrame(() => { const contentW = contentSpan.scrollWidth, containerW = container.offsetWidth; if (contentW > containerW) { duplicateSpan.innerHTML = text; container.classList.add('scrolling'); setStyle(inner, { animationDuration: `${contentW / 40}s` }); } else { duplicateSpan.innerHTML = ''; container.classList.remove('scrolling'); } }); // 判斷是否需要滾動並設定動畫
		}
		function initializeAnalogClock() { // 初始化類比時鐘的刻度和數字
			const container = qs('#ticks-container'); container.innerHTML = ''; // 清空容器
			for (let i = 1; i <= 60; i++) { // 迴圈 60 次 (分鐘)
				const isHour = i % 5 === 0, rotation = i * 6; // 判斷是否為小時刻度並計算旋轉角度
				const wrapper = document.createElement('div'); wrapper.className = 'tick-wrapper'; setStyle(wrapper, { transform: `rotate(${rotation}deg)` }); // 創建刻度包裝元素並旋轉
				const tick = document.createElement('div'); tick.className = isHour ? 'tick tick-hour' : 'tick tick-minute'; wrapper.appendChild(tick); // 創建刻度元素並加入
				if (isHour) { wrapper.style.setProperty('--rotation', `${rotation}deg`); const numDiv = document.createElement('div'); numDiv.className = 'number'; numDiv.innerHTML = `<div>${i / 5}</div>`; wrapper.appendChild(numDiv); } // 如果是小時，則加入數字
				container.appendChild(wrapper); // 將刻度包裝元素加入容器
			}
		}
		function updateAnalogClock() { // 更新類比時鐘的指針位置和類比日曆
			if (!settings.showAnalogClock && !settings.showAnalogCalendar) return; // 如果都沒顯示，則不執行
			const now = new Date(), s = now.getSeconds() + now.getMilliseconds() / 1000, m = now.getMinutes() + s / 60, h = now.getHours() % 12 + m / 60; // 計算時分秒的精確角度
			if (settings.showAnalogClock) { setStyle(qs('.hour-hand'), { transform: `rotate(${(h / 12) * 360}deg)` }); setStyle(qs('.minute-hand'), { transform: `rotate(${(m / 60) * 360}deg)` }); setStyle(qs('.second-hand'), { transform: `rotate(${(s / 60) * 360}deg)` }); } // 更新指針旋轉
			if (settings.showAnalogCalendar) { const todayCell = qs('#analog-calendar-grid .is-today .gregorian-day'); if (!todayCell || new Date().getDate() !== parseInt(todayCell.textContent)) createAnalogCalendar(); } // 如果日期變更，則重新生成類比日曆
		}
		function createAnalogCalendar() { // 生成類比日曆的內容
			const now = new Date(), year = now.getFullYear(), month = now.getMonth(); // 獲取當年和當月
			qs('#analog-calendar-widget .analog-calendar-bg-month').textContent = month + 1; // 設定背景月份
			const grid = qs('#analog-calendar-grid'); grid.innerHTML = ''; // 清空日曆網格
			['日', '一', '二', '三', '四', '五', '六'].forEach(day => { const el = document.createElement('div'); el.textContent = day; el.className = 'weekday-header'; grid.appendChild(el); }); // 加入星期標頭
			if (state.yearlyDataCache.year !== year) { getHolidaysForYear(year); getJieqiForYear(year); } // 檢查年度快取
			const { holidays, jieqi } = state.yearlyDataCache; // 獲取節日和節氣資料
			const startDate = new Date(year, month, 1 - new Date(year, month, 1).getDay()); // 計算日曆的第一天
			for (let i = 0; i < 42; i++) { // 迴圈生成 42 個日期格
				const date = new Date(startDate); date.setDate(startDate.getDate() + i); // 計算當前日期
				const cell = document.createElement('div'); cell.className = 'calendar-day'; // 創建日期格元素
				if (date.getMonth() !== month) cell.classList.add('other-month'); // 標記非本月的日期
				cell.dataset.date = date.toISOString(); // 儲存日期資料
				cell.onclick = (e) => { e.stopPropagation(); showDateDetails(new Date(cell.dataset.date)); }; // 綁定點擊事件以顯示詳情
				const lunar = Solar.fromDate(date).getLunar(); // 獲取農曆資訊
				const lunarText = lunar.getDay() === 1 ? s2t(lunar.getMonthInChinese()) + '月' : s2t(lunar.getDayInChinese()); // 格式化農曆文字
				let eventHtml = ''; // 初始化事件 HTML
				if (date.getMonth() === month) { // 只處理本月的事件
					const holiday = holidays.find(h => h.date.toDateString() === date.toDateString()); // 尋找節日
					if (holiday) eventHtml += `<span class="event-indicator holiday">${holiday.name}</span>`; // 加入節日標記
					const jq = jieqi.find(j => j.date.toDateString() === date.toDateString()); // 尋找節氣
					if (jq) eventHtml += `<span class="event-indicator jieqi">${jq.name}</span>`; // 加入節氣標記
				}
				cell.innerHTML = `<div class="analog-day-main"><div class="gregorian-day">${date.getDate()}</div><div class="lunar-day">${lunarText}</div></div><div class="analog-day-events">${eventHtml}</div>`; // 填入日期格內容
				if (date.toDateString() === now.toDateString()) cell.classList.add('is-today'); // 標記今天
				grid.appendChild(cell); // 將日期格加入網格
			}
		}
		function updateWeatherDisplay() { // 更新天氣資訊的顯示
			if (!settings.showWeather) { state.lastWeatherContent = ''; updateDigitalClock(); return; } // 如果不顯示天氣，則清空並返回
			let weatherText = `<span style="color: ${settings.weatherColor};">無法取得天氣資訊</span>`; // 預設的錯誤訊息
			if (state.weatherDataCache) { // 如果有天氣資料快取
				const { desc } = getWeatherDescriptionAndEmoji(state.weatherDataCache.current.weather_code); // 獲取天氣描述
				const icon = getWeatherSVGIcon(state.weatherDataCache.current.weather_code, '1em'); // 獲取天氣圖示
				const temp = Math.round(state.weatherDataCache.current.temperature_2m); // 獲取溫度
				const location = settings.showWeatherLocation ? `<span style="color: ${settings.weatherLocationColor};">${getChineseLocationName(settings.weatherLocation)}</span> ` : ''; // 獲取地點名稱
				weatherText = `${location}<span style="color: ${settings.weatherColor};">${desc}${icon}${temp}°C</span>`; // 組合天氣文字
			}
			state.lastWeatherContent = weatherText; updateMarquee(weatherText, 'weather'); // 更新跑馬燈
		}
		async function updateWeather() { // 異步獲取並更新天氣資料
			const locationName = settings.weatherLocation.trim(); // 獲取地點名稱
			if (!locationName) { state.weatherDataCache = null; updateWeatherDisplay(); return; } // 如果地點為空，則清空資料並返回
			const coords = await fetchCoordinates(locationName); // 獲取地點的經緯度
			state.weatherDataCache = coords ? await fetchWeather(coords.latitude, coords.longitude) : null; // 根據經緯度獲取天氣資料
			updateWeatherDisplay(); // 更新天氣顯示
		}
		async function fetchAPI(url) { try { const response = await fetch(url); if (!response.ok) throw new Error('API請求失敗'); return await response.json(); } catch (error) { console.error(`獲取資料失敗: ${url}`, error); return null; } } // 異步 API 請求的輔助函式
		async function fetchCoordinates(name) { const data = await fetchAPI(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(name)}&count=1&language=en&format=json`); return data?.results?.[0] || null; } // 根據地名獲取經緯度
		async function fetchWeather(lat, lon) { return await fetchAPI(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,weather_code&hourly=temperature_2m,weather_code&daily=weather_code,temperature_2m_max,temperature_2m_min&timezone=auto&forecast_days=8`); } // 根據經緯度獲取天氣預報
		function getChineseLocationName(englishName) { for (const county in taiwanLocations) { for (const district in taiwanLocations[county].districts) { if (taiwanLocations[county].districts[district].toLowerCase() === englishName.toLowerCase()) return county === district ? county : district; } } return englishName; } // 將英文地名轉換為中文
		function updateMainMoonPhaseDisplay(date) { // 更新月相詳情彈出視窗中的主要顯示區域
			const lunar = Solar.fromDate(date).getLunar(), day = lunar.getDay(), details = getMoonPhaseDetails(day); // 獲取農曆日期和月相詳情
			const title = details.aka ? `${details.name} (${details.aka})` : details.name; // 格式化標題
			qs('#moonPhaseModalTitle').textContent = `月相詳情：${title}`; // 設定標題
			qs('#mainMoonIcon').innerHTML = getMoonPhaseSVG(day, '100px'); // 設定大的月相圖示
			qs('#mainMoonDescription').textContent = details.desc; // 設定月相描述
			qsa('#moonCalendarGrid .calendar-day').forEach(d => d.classList.remove('is-selected')); // 移除所有日期的選中狀態
			const selectedDayEl = qs(`#moonCalendarGrid .calendar-day[data-date-string='${date.toDateString()}']`); // 找到對應的日期元素
			if (selectedDayEl) selectedDayEl.classList.add('is-selected'); // 標記為選中
		}
		function generateMoonPhaseCalendar(year, month, selectedDate) { // 生成月相詳情彈出視窗中的小日曆
			const grid = qs('#moonCalendarGrid'), monthYear = qs('#moonCalendarMonthYear'), weekdaysEl = qs('#moonCalendarWeekdays'); // 獲取元素
			grid.innerHTML = ''; weekdaysEl.innerHTML = ''; // 清空內容
			['日', '一', '二', '三', '四', '五', '六'].forEach(day => { const el = document.createElement('div'); el.textContent = day; weekdaysEl.appendChild(el); }); // 加入星期標頭
			monthYear.textContent = `${year}年 ${month + 1}月`; // 設定年月標題
			const startDate = new Date(year, month, 1 - new Date(year, month, 1).getDay()), today = new Date(); // 計算日曆起始日期
			for (let i = 0; i < 42; i++) { // 迴圈生成 42 個日期格
				const date = new Date(startDate); date.setDate(startDate.getDate() + i); date.setHours(12, 0, 0, 0); // 計算當前日期
				const cell = document.createElement('div'); cell.className = 'calendar-day'; // 創建日期格
				if (date.getMonth() !== month) cell.classList.add('other-month'); // 標記非本月日期
				cell.dataset.dateString = date.toDateString(); // 儲存日期字串
				cell.onclick = () => { state.moonCalendarDate = new Date(date); updateMainMoonPhaseDisplay(state.moonCalendarDate); }; // 綁定點擊事件
				const lunar = Solar.fromDate(date).getLunar(); // 獲取農曆資訊
				const lunarText = lunar.getDay() === 1 ? s2t(lunar.getMonthInChinese()) + '月' : s2t(lunar.getDayInChinese()); // 格式化農曆文字
				cell.innerHTML = `<div class="gregorian-day">${date.getDate()}</div><div class="moon-phase-icon-small">${getMoonPhaseSVG(lunar.getDay(), '24px')}</div><div class="lunar-day">${lunarText}</div>`; // 填入內容
				if (today.toDateString() === date.toDateString()) cell.classList.add('is-today'); // 標記今天
				if (selectedDate.toDateString() === date.toDateString()) cell.classList.add('is-selected'); // 標記選中的日期
				grid.appendChild(cell); // 加入到網格
			}
		}
		function showMoonPhaseDetails(date) { // 顯示月相詳情彈出視窗
			if (settings.editMode) return; // 編輯模式下不執行
			const d = new Date(date); d.setHours(12, 0, 0, 0); // 創建日期物件並標準化時間
			state.moonCalendarDate = d; updateMainMoonPhaseDisplay(d); generateMoonPhaseCalendar(d.getFullYear(), d.getMonth(), d); qs('#moonPhaseModal').classList.add('is-active'); // 更新狀態、UI 並顯示彈窗
		}
		function showDateDetails(date) { // 顯示指定日期的詳細資訊彈出視窗
			if (settings.editMode) return; // 編輯模式下不執行
			date.setHours(12, 0, 0, 0); const year = date.getFullYear(); // 標準化時間並獲取年份
			const holidays = getHolidaysForYear(year), jieqi = getJieqiForYear(year); // 獲取年度資料
			const isToday = date.toDateString() === new Date().toDateString(); // 判斷是否為今天
			const lunar = Solar.fromDate(date).getLunar(); // 獲取農曆物件
			const shengxiao = s2t(lunar.getYearShengXiao()); // 獲取生肖
			const lunarYearText = `${s2t(lunar.getYearInGanZhi())}${shengxiao}${getShengXiaoSVG(shengxiao)}年`; // 組合農曆年份文字
			const lunarDateText = `${s2t(lunar.getMonthInChinese())}月${s2t(lunar.getDayInChinese())}`; // 組合農曆月日文字
			let eventHtml = '', countdownHtml = ''; // 初始化事件和倒數計時的 HTML
			const currentJieqi = jieqi.find(j => j.date.toDateString() === date.toDateString()); // 尋找當天的節氣
			if (currentJieqi) eventHtml += `<p>${isToday ? '今天是' : '這天是'} <strong>${currentJieqi.name}</strong>！ ${getJieqiDescription(currentJieqi.name)}</p>`; // 加入節氣資訊
			const currentHoliday = holidays.find(h => h.date.toDateString() === date.toDateString()); // 尋找當天的節日
			if (currentHoliday) eventHtml += `<p>${isToday ? '今天是' : '這天是'} <strong>${currentHoliday.name}</strong>！</p>`; // 加入節日資訊
			const nextJieqi = jieqi.find(j => j.date > date); // 尋找下一個節氣
			if (nextJieqi) { const days = Math.ceil((nextJieqi.date - date) / 864e5); countdownHtml += `<p>距離下個節氣 <strong>${nextJieqi.name}</strong> 還有 ${days} 天。<br><span style="font-size:0.9em; color:#ccc;">${getJieqiDescription(nextJieqi.name)}</span></p>`; } // 加入下一個節氣的倒數
			const nextHoliday = holidays.find(h => h.date > date); // 尋找下一個節日
			if (nextHoliday) { const days = Math.ceil((nextHoliday.date - date) / 864e5); countdownHtml += `<p>距離下個節日 <strong>${nextHoliday.name}</strong> 還有 ${days} 天</p>`; } // 加入下一個節日的倒數
			if (countdownHtml) eventHtml += `<div class="countdown-section">${countdownHtml}</div>`; // 組合倒數計時 HTML
			const detailsHtml = `<p><strong>公曆：</strong>${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日</p><p><strong>農曆：</strong>${lunarYearText} ${lunarDateText} ${getMoonPhaseSVG(lunar.getDay(), '1.2em')}</p><div class="yi-ji-grid"><strong>宜：</strong><span>${s2t(lunar.getDayYi()).join('、') || '無'}</span><strong>忌：</strong><span>${s2t(lunar.getDayJi()).join('、') || '無'}</span></div>${eventHtml}<p style="margin-top: 15px; font-size: 0.9em; color: #aaa;">宜忌僅供參考，請順心而為。</p>`; // 組合最終的詳細資訊 HTML
			qs('#dateDetailsModalTitle').textContent = `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`; // 設定彈窗標題
			qs('#dateDetailsModalContent').innerHTML = detailsHtml; qs('#dateDetailsModal').classList.add('is-active'); // 填入內容並顯示彈窗
		}
		function updateShiChenDetailsView(date) { // 更新時辰詳情彈出視窗的內容
			if (settings.editMode) return; // 編輯模式下不執行
			state.shichenDetailDate = new Date(date); const lunar = Solar.fromDate(state.shichenDetailDate).getLunar(); const hour = state.shichenDetailDate.getHours(); const name = getShiChen(hour); qs('#shichenDetailsModalTitle').textContent = `${state.shichenDetailDate.getMonth() + 1}月${state.shichenDetailDate.getDate()}日 ${name}時`; const lunarTime = lunar.getTimes().find(lt => lt.getZhi() === name); if (lunarTime) { qs('#shichenDetailsModalContent').innerHTML = `<p><strong>時辰：</strong>${name}時 (${s2t(lunarTime.getGan() + lunarTime.getZhi())}) <span style="font-size: 0.9em; color: #ccc;">${getShiChenTimeRange(name)}</span></p><div class="yi-ji-grid"><strong>宜：</strong><span>${s2t(lunarTime.getYi()).join('、') || '無'}</span><strong>忌：</strong><span>${s2t(lunarTime.getJi()).join('、') || '無'}</span></div><p style="margin-top: 15px; font-size: 0.9em; color: #aaa;">時辰宜忌僅供參考。</p>`; } else { qs('#shichenDetailsModalContent').innerHTML = `<p>找不到 ${name}時 的詳細資訊。</p>`; } qs('#shichenDetailsModal').classList.add('is-active'); // 填入內容並顯示彈窗
		}
		function generateCalendarPopup(year, month) { // 生成月份日曆彈出視窗
			const grid = qs('#calendarGrid'), monthYear = qs('#calendarMonthYear'), weekdaysEl = qs('#calendarWeekdays'); // 獲取元素
			grid.innerHTML = ''; weekdaysEl.innerHTML = ''; // 清空內容
			addCalendarBgMonth(qs('#calendarModal .modal-content'), month + 1); // 加入背景月份
			['日', '一', '二', '三', '四', '五', '六'].forEach(day => { const el = document.createElement('div'); el.textContent = day; weekdaysEl.appendChild(el); }); // 加入星期標頭
			monthYear.textContent = `${year}年`; monthYear.dataset.year = year; monthYear.dataset.month = month; // 設定年月標題和資料
			if (state.yearlyDataCache.year !== year) { getHolidaysForYear(year); getJieqiForYear(year); } // 檢查年度快取
			const { holidays, jieqi } = state.yearlyDataCache; // 獲取年度資料
			const startDate = new Date(year, month, 1 - new Date(year, month, 1).getDay()); // 計算起始日期
			for (let i = 0; i < 42; i++) { // 迴圈生成 42 個日期格
				const date = new Date(startDate); date.setDate(startDate.getDate() + i); // 計算當前日期
				const cell = document.createElement('div'); cell.className = 'calendar-day'; // 創建日期格
				if (date.getMonth() !== month) cell.classList.add('other-month'); // 標記非本月日期
				cell.dataset.date = date.toISOString(); cell.onclick = () => showDateDetails(new Date(cell.dataset.date)); // 綁定點擊事件
				const lunar = Solar.fromDate(date).getLunar(); // 獲取農曆資訊
				cell.innerHTML = `<div class="gregorian-day">${date.getDate()}</div><div class="lunar-day">${lunar.getDay() === 1 ? s2t(lunar.getMonthInChinese()) + '月' : s2t(lunar.getDayInChinese())}</div>`; // 填入公農曆日期
				if (date.toDateString() === new Date().toDateString()) cell.classList.add('is-today'); // 標記今天
				if (date.getMonth() === month) { // 只處理本月的事件
					const holiday = holidays.find(h => h.date.toDateString() === date.toDateString()); // 尋找節日
					if (holiday) cell.innerHTML += `<span class="event-indicator holiday">${holiday.name}</span>`; // 加入節日標記
					const jq = jieqi.find(j => j.date.toDateString() === date.toDateString()); // 尋找節氣
					if (jq) cell.innerHTML += `<span class="event-indicator jieqi">${jq.name}</span>`; // 如果有節氣，則在儲存格內新增節氣指示符
				}
				grid.appendChild(cell); // 將日期儲存格加入到月曆網格中
			}
		}
		function generateWeekCalendar(baseDate) { // 定義一個函式來生成週曆
			const grid = qs('#weeklyCalendarGrid'), title = qs('#weeklyCalendarTitle'); // 獲取週曆的網格和標題元素
			grid.innerHTML = ''; // 清空週曆網格的現有內容
			const today = new Date(), start = new Date(baseDate); // 獲取今天的日期，並以基準日期建立一個新的開始日期物件
			start.setDate(baseDate.getDate() - baseDate.getDay()); // 將開始日期設定為本週的星期日
			const end = new Date(start); // 以開始日期為基礎建立一個結束日期物件
			end.setDate(start.getDate() + 6); // 將結束日期設定為本週的星期六
			title.textContent = `${start.getFullYear()}年${start.getMonth() + 1}月${start.getDate()}日 - ${end.getFullYear()}年${end.getMonth() + 1}月${end.getDate()}日`; // 設定週曆的標題，顯示日期範圍
			const weekdays = ['周日', '周一', '周二', '周三', '周四', '周五', '周六']; // 定義一週中每天的中文名稱
			const holidays = getHolidaysForYear(baseDate.getFullYear()), jieqi = getJieqiForYear(baseDate.getFullYear()); // 獲取基準日期所在年份的假日和節氣資訊
			for (let i = 0; i < 7; i++) { // 迴圈遍歷一週的七天
				const day = new Date(start); // 以本週開始日期為基礎建立一個新的日期物件
				day.setDate(start.getDate() + i); // 設定日期為本週的第 i 天
				const cell = document.createElement('div'); // 為這一天建立一個 div 元素作為儲存格
				cell.className = 'weekly-calendar-day'; // 設定儲存格的 CSS class
				cell.dataset.date = day.toISOString(); // 將日期的 ISO 格式字串存儲在 data-date 屬性中
				cell.onclick = () => showDateDetails(new Date(cell.dataset.date)); // 設定點擊事件，點擊時顯示該日期的詳細資訊
				if (day.toDateString() === today.toDateString()) cell.classList.add('is-today'); // 如果這一天是今天，則新增 'is-today' class 以突顯
				const lunar = Solar.fromDate(day).getLunar(); // 從陽曆日期獲取對應的農曆資訊
				cell.innerHTML = `<div class="weekly-day-header">${weekdays[i]}</div><div class="weekly-gregorian-day">${day.getDate()}</div><div class="weekly-lunar-day">${lunar.getDay() === 1 ? s2t(lunar.getMonthInChinese()) + '月' : s2t(lunar.getDayInChinese())}</div>`; // 設定儲存格的 HTML 內容，包括星期、陽曆日期和農曆日期（或月份）
				const holiday = holidays.find(h => h.date.toDateString() === day.toDateString()); // 查找這一天是否有對應的假日
				if (holiday) cell.innerHTML += `<span class="event-indicator holiday">${holiday.name}</span>`; // 如果有假日，則新增假日指示符
				const jq = jieqi.find(j => j.date.toDateString() === day.toDateString()); // 查找這一天是否有對應的節氣
				if (jq) cell.innerHTML += `<span class="event-indicator jieqi">${jq.name}</span>`; // 如果有節氣，則新增節氣指示符
				grid.appendChild(cell); // 將建立的日期儲存格加入到週曆網格中
			}
		}
		function generateYearCalendar(year) { // 定義一個函式來生成年曆
			const grid = qs('#yearlyCalendarGrid'), title = qs('#yearlyCalendarTitle'); // 獲取年曆的網格和標題元素
			grid.innerHTML = ''; // 清空年曆網格的現有內容
			title.textContent = `${year}年`; // 設定年曆的標題為指定的年份
			const today = new Date(), weekdays = ['日', '一', '二', '三', '四', '五', '六']; // 獲取今天的日期，並定義星期的中文簡稱
			const holidays = getHolidaysForYear(year), jieqi = getJieqiForYear(year); // 獲取指定年份的假日和節氣資訊
			for (let month = 0; month < 12; month++) { // 迴圈遍歷一年的十二個月
				const monthContainer = document.createElement('div'); // 為每個月建立一個容器 div
				monthContainer.className = 'yearly-month-container'; // 設定月份容器的 CSS class
				monthContainer.style.cursor = 'pointer'; // 設定滑鼠指標為手形，提示可點擊
				monthContainer.title = `查看 ${month + 1}月 月曆`; // 設定工具提示，顯示點擊後的操作
				monthContainer.onclick = () => { // 設定點擊事件
					if (settings.editMode) return; // 如果處於編輯模式，則不執行任何操作
					qs('#yearlyCalendarModal').classList.remove('is-active'); // 隱藏年曆的彈出視窗
					state.calendarDate.setFullYear(year, month, 1); // 將全域日曆狀態的日期設定為點擊的年份和月份
					generateCalendarPopup(year, month); // 生成對應月份的月曆彈出視窗
					qs('#calendarModal').classList.add('is-active'); // 顯示月曆彈出視窗
				};
				addCalendarBgMonth(monthContainer, month + 1); // 為月份容器新增背景月份數字
				const weekdaysDiv = document.createElement('div'); // 建立一個 div 來放置星期標題
				weekdaysDiv.className = 'yearly-weekdays'; // 設定星期標題容器的 CSS class
				weekdays.forEach(day => { // 遍歷星期陣列
					const el = document.createElement('div'); // 為每個星期建立一個 div
					el.textContent = day; // 設定 div 的文字內容為星期的簡稱
					weekdaysDiv.appendChild(el); // 將星期的 div 加入到星期標題容器中
				});
				monthContainer.appendChild(weekdaysDiv); // 將星期標題容器加入到月份容器中
				const dayGrid = document.createElement('div'); // 建立一個 div 來放置該月的日期網格
				dayGrid.className = 'yearly-day-grid'; // 設定日期網格的 CSS class
				const firstDay = new Date(year, month, 1).getDay(), daysInMonth = new Date(year, month + 1, 0).getDate(); // 獲取該月的第一天是星期幾，以及該月總共有幾天
				for (let i = 0; i < firstDay; i++) dayGrid.appendChild(document.createElement('div')); // 在日期網格的開頭新增空白 div，以對齊星期
				for (let dayNum = 1; dayNum <= daysInMonth; dayNum++) { // 迴圈遍歷該月的每一天
					const cell = document.createElement('div'); // 為每一天建立一個儲存格 div
					cell.className = 'yearly-day'; // 設定日期儲存格的 CSS class
					const date = new Date(year, month, dayNum); // 為這一天建立一個 Date 物件
					cell.dataset.date = date.toISOString(); // 將日期的 ISO 格式字串存儲在 data-date 屬性中
					cell.onclick = (e) => { // 設定點擊事件
						e.stopPropagation(); // 阻止事件冒泡到父層的月份容器
						showDateDetails(new Date(cell.dataset.date)); // 顯示該日期的詳細資訊
					};
					cell.textContent = dayNum; // 設定儲存格的文字內容為日期數字
					if (today.getFullYear() === year && today.getMonth() === month && dayNum === today.getDate()) cell.classList.add('is-today'); // 如果這一天是今天，則新增 'is-today' class 以突顯
					const holiday = holidays.find(h => h.date.toDateString() === date.toDateString()); // 查找這一天是否有對應的假日
					const jq = jieqi.find(j => j.date.toDateString() === date.toDateString()); // 查找這一天是否有對應的節氣
					if(holiday || jq) { // 如果這一天有假日或節氣
						const indicators = document.createElement('div'); // 建立一個 div 來放置指示符
						indicators.className = 'yearly-indicators'; // 設定指示符容器的 CSS class
						if(holiday) indicators.innerHTML += '<span class="dot holiday"></span>'; // 如果有假日，新增一個假日指示點
						if(jq) indicators.innerHTML += '<span class="dot jieqi"></span>'; // 如果有節氣，新增一個節氣指示點
						cell.appendChild(indicators); // 將指示符容器加入到日期儲存格中
					}
					dayGrid.appendChild(cell); // 將日期儲存格加入到日期網格中
				}
				monthContainer.appendChild(dayGrid); // 將日期網格加入到月份容器中
				grid.appendChild(monthContainer); // 將月份容器加入到年曆的總網格中
			}
		}
		function showWeatherForecast() { // 定義一個函式來顯示天氣預報
			if (settings.editMode) return; // 如果處於編輯模式，則不執行任何操作
			if (!state.weatherDataCache) { // 如果沒有快取的天氣資料
				const el = qs('#weatherMarqueeContainer'); // 獲取天氣跑馬燈的容器元素
				if(el) { // 如果元素存在
					setStyle(el, { backgroundColor: '#552222' }); // 設定背景顏色為紅色以示警告
					setTimeout(() => setStyle(el, { backgroundColor: '' }), 500); // 500 毫秒後恢復原來的背景顏色
				}
				return; // 結束函式執行
			}
			const grid = qs('#weatherForecastGrid'), title = qs('#weatherForecastModalTitle'); // 獲取天氣預報的網格和標題元素
			grid.innerHTML = ''; // 清空天氣預報網格的現有內容
			title.textContent = `${getChineseLocationName(settings.weatherLocation)} 一週預報`; // 設定標題，顯示地點和預報類型
			for (let i = 0; i < 7; i++) { // 迴圈顯示未來七天的預報
				const date = new Date(state.weatherDataCache.daily.time[i]); // 從快取資料中獲取第 i 天的日期
				const dayName = i === 0 ? '今天' : `周${['日', '一', '二', '三', '四', '五', '六'][date.getDay()]}`; // 如果是第一天則顯示'今天'，否則顯示'周X'
				const { desc } = getWeatherDescriptionAndEmoji(state.weatherDataCache.daily.weather_code[i]); // 根據天氣代碼獲取天氣描述
				const dayCell = document.createElement('div'); // 為這一天的預報建立一個 div 元素
				dayCell.className = 'forecast-day'; // 設定預報儲存格的 CSS class
				dayCell.innerHTML = `<p class="day-name">${dayName}</p><p>${date.getMonth() + 1}/${date.getDate()}</p><div class="weather-icon">${getWeatherSVGIcon(state.weatherDataCache.daily.weather_code[i], '2.5em')}</div><p>${desc}</p><p><span class="temp-high">${Math.round(state.weatherDataCache.daily.temperature_2m_max[i])}°</span> / <span class="temp-low">${Math.round(state.weatherDataCache.daily.temperature_2m_min[i])}°</span></p>`; // 設定儲存格的 HTML 內容，包括日期、天氣圖示、描述、最高溫和最低溫
				dayCell.onclick = () => showHourlyWeather(i); // 設定點擊事件，點擊時顯示該天的每小時天氣
				grid.appendChild(dayCell); // 將預報儲存格加入到網格中
			}
			qs('#weatherForecastModal').classList.add('is-active'); // 顯示天氣預報的彈出視窗
		}
		function showHourlyWeather(dayIndex) { // 定義一個函式來顯示每小時天氣
			if (!state.weatherDataCache?.hourly) return; // 如果沒有快取的每小時天氣資料，則不執行任何操作
			const grid = qs('#hourlyWeatherGrid'), title = qs('#hourlyWeatherModalTitle'); // 獲取每小時天氣的網格和標題元素
			grid.innerHTML = ''; // 清空網格的現有內容
			const date = new Date(state.weatherDataCache.daily.time[dayIndex]); // 獲取選定日期的 Date 物件
			const max = Math.round(state.weatherDataCache.daily.temperature_2m_max[dayIndex]), min = Math.round(state.weatherDataCache.daily.temperature_2m_min[dayIndex]); // 獲取並四捨五入當天的最高溫和最低溫
			title.innerHTML = `${date.getMonth() + 1}月${date.getDate()}日 預報 <span style="font-size: 0.7em; color: #ccc;">(高 <span class="temp-high">${max}°</span> / 低 <span class="temp-low">${min}°</span>)</span>`; // 設定標題，顯示日期和當天的高低溫
			const now = new Date(); // 獲取當前時間
			const start = dayIndex * 24, end = start + 24; // 計算在每小時資料陣列中對應的起始和結束索引
			for (let i = start; i < end; i += 3) { // 以 3 小時為間隔遍歷當天的每小時資料
				const hourDate = new Date(state.weatherDataCache.hourly.time[i]); // 獲取該時間點的 Date 物件
				const { desc } = getWeatherDescriptionAndEmoji(state.weatherDataCache.hourly.weather_code[i]); // 根據天氣代碼獲取天氣描述
				const hourCell = document.createElement('div'); // 為該時間點建立一個 div 元素
				hourCell.className = 'hourly-item'; // 設定 CSS class
				if (dayIndex === 0) { // 如果顯示的是今天的天氣
					const currentHour = now.getHours(), blockStartHour = hourDate.getHours(); // 獲取當前小時和該時間區塊的起始小時
					if (currentHour >= blockStartHour && currentHour < blockStartHour + 3) hourCell.classList.add('is-now'); // 如果當前時間落在該區塊內，則新增 'is-now' class 以突顯
				}
				hourCell.innerHTML = `<p class="hour-time">${hourDate.getHours().toString().padStart(2, '0')}:00</p><div class="weather-icon">${getWeatherSVGIcon(state.weatherDataCache.hourly.weather_code[i], '2em')}</div><p>${desc}</p><p>${Math.round(state.weatherDataCache.hourly.temperature_2m[i])}°C</p>`; // 設定儲存格的 HTML 內容，包括時間、圖示、描述和溫度
				grid.appendChild(hourCell); // 將儲存格加入到網格中
			}
			qs('#weatherForecastModal').classList.remove('is-active'); // 隱藏一週預報的彈出視窗
			qs('#hourlyWeatherModal').classList.add('is-active'); // 顯示每小時天氣的彈出視窗
		}
		function showZodiacDetails() { // 定義一個函式來顯示十二生肖的詳細資訊
			if (settings.editMode) return; // 如果處於編輯模式，則不執行任何操作
			const grid = qs('#zodiacGrid'); // 獲取十二生肖的網格元素
			grid.innerHTML = ''; // 清空網格的現有內容
			['鼠', '牛', '虎', '兔', '龍', '蛇', '馬', '羊', '猴', '雞', '狗', '豬'].forEach(name => { // 遍歷十二生肖陣列
				const item = document.createElement('div'); // 為每個生肖建立一個 div 元素
				item.className = 'zodiac-item'; // 設定 CSS class
				item.innerHTML = `<div class="zodiac-icon">${getShengXiaoSVG(name, '100%')}</div><p>${name}</p>`; // 設定 HTML 內容，包括生肖的 SVG 圖示和名稱
				grid.appendChild(item); // 將生肖項目加入到網格中
			});
			qs('#zodiacModal').classList.add('is-active'); // 顯示十二生肖的彈出視窗
		}
		function updateDistrictSelector(county) { // 定義一個函式來更新鄉鎮市區的下拉選單
			const sel = qs('#districtSelect'); // 獲取鄉鎮市區的 select 元素
			sel.innerHTML = ''; // 清空選單的現有選項
			const districts = taiwanLocations[county]?.districts || {}; // 根據選擇的縣市獲取其下的鄉鎮市區列表，如果沒有則為空物件
			for (const name in districts) { // 遍歷鄉鎮市區物件
				const opt = document.createElement('option'); // 建立一個 option 元素
				opt.value = name; // 設定 option 的 value 為鄉鎮市區的中文名
				opt.textContent = name; // 設定 option 顯示的文字為鄉鎮市區的中文名
				sel.appendChild(opt); // 將 option 加入到下拉選單中
			}
		}
		function syncLocationControls() { // 定義一個函式來同步地點相關的控制項
			const county = qs('#countySelect').value, district = qs('#districtSelect').value; // 獲取當前選擇的縣市和鄉鎮市區
			const english = taiwanLocations[county]?.districts[district] || 'taiwan'; // 根據中文名稱查找對應的英文地點名稱，如果找不到則預設為 'taiwan'
			qs('#weatherLocation').value = english; // 更新隱藏的英文地點輸入框的值
			settings.weatherLocation = english; // 更新設定物件中的天氣地點
			saveState(); // 保存目前的設定狀態
			updateWeather(); // 更新天氣資訊
		}
		function setLocationSelectorsFromEnglish(english) { // 定義一個函式，根據英文地點名稱來設定縣市和鄉鎮市區的下拉選單
			const countySel = qs('#countySelect'), districtSel = qs('#districtSelect'); // 獲取縣市和鄉鎮市區的 select 元素
			qs('#weatherLocation').value = english; // 更新隱藏的英文地點輸入框的值
			let found = false; // 初始化一個標誌來表示是否已找到對應地點
			for (const county in taiwanLocations) { // 遍歷台灣所有縣市
				for (const district in taiwanLocations[county].districts) { // 遍歷該縣市下的所有鄉鎮市區
					if (taiwanLocations[county].districts[district].toLowerCase() === english.toLowerCase()) { // 如果找到匹配的英文地點（不分大小寫）
						countySel.value = county; // 設定縣市下拉選單的值
						updateDistrictSelector(county); // 更新鄉鎮市區下拉選單的內容
						districtSel.value = district; // 設定鄉鎮市區下拉選單的值
						found = true; // 將標誌設為 true
						break; // 跳出內層迴圈
					}
				}
				if (found) break; // 如果已找到，則跳出外層迴圈
			}
			if (!found) { // 如果遍歷完畢仍未找到
				countySel.value = '台灣'; // 將縣市設定為 '台灣'
				updateDistrictSelector('台灣'); // 更新鄉鎮市區選單
				districtSel.value = '台灣'; // 將鄉鎮市區設定為 '台灣'
			}
		}
		function constrainPositions() { // 定義一個函式來限制元件的位置，使其不會超出視窗範圍
			const handleSize = 40, margin = 10; // 定義控制點大小和邊界距離
			const minX = -window.innerWidth / 2 + handleSize / 2 + margin, maxX = window.innerWidth / 2 - handleSize / 2 - margin; // 計算 X 軸的最小和最大允許座標
			const minY = -window.innerHeight / 2 + handleSize / 2 + margin, maxY = window.innerHeight / 2 - handleSize / 2 - margin; // 計算 Y 軸的最小和最大允許座標
			let needsUpdate = false; // 初始化一個標誌來表示是否有位置被更動
			for (const id in transformState) { // 遍歷所有元件的變換狀態
				if (id === 'master') continue; // 忽略 'master' 主控制項
				const T = transformState[id]; // 獲取該元件的變換狀態物件
				if (T && typeof T.x === 'number' && typeof T.y === 'number') { // 確保該元件有 x 和 y 座標
					const originalX = T.x, originalY = T.y; // 保存原始座標
					T.x = Math.max(minX, Math.min(maxX, T.x)); // 將 x 座標限制在允許的範圍內
					T.y = Math.max(minY, Math.min(maxY, T.y)); // 將 y 座標限制在允許的範圍內
					if (T.x !== originalX || T.y !== originalY) needsUpdate = true; // 如果座標有被更動，則將標誌設為 true
				}
			}
			return needsUpdate; // 返回是否需要更新畫面的標誌
		}
		function initializeEventListeners() { // 定義一個函式來初始化所有的事件監聽器
			qs('#settingsModal').addEventListener('change', e => { // 監聽設定彈出視窗中的 'change' 事件
				const { id, type, checked, value } = e.target; // 從事件目標中解構獲取 id、類型、是否選中和值
				if (['countySelect', 'districtSelect', 'weatherLocation'].includes(id)) return; // 如果是地點選擇器，則不在此處理
				settings[id] = type === 'checkbox' ? checked : value; // 根據元素類型（核取方塊或其它）更新設定物件
				if (id.startsWith('enableMovement') || id.includes('movementInterval')) applyMovement(); // 如果是移動相關的設定，則應用移動效果
				else if (id.startsWith('enableBackgroundScanline') || id.startsWith('enableTextScanline') || id.includes('scanlineInterval')) { applyScanlineEffect(); updateDigitalClock(); } // 如果是掃描線效果相關的設定，則應用效果並更新數位時鐘
				else if (id.startsWith('show')) { updateWidgetVisibility(); applyAllSettings(); } // 如果是顯示/隱藏元件的設定，則更新可見性並應用所有設定
				else applyAllSettings(); // 對於其它設定，直接應用所有設定
				updateSettingDependencies(); saveState(); // 更新相關設定的依賴項並保存狀態
			});
			qsa('#settingsModal input[type="color"]').forEach(el => el.addEventListener('input', e => { settings[e.target.id] = e.target.value; applyAllSettings(); saveState(); })); // 為所有顏色選擇器新增 'input' 事件監聽，即時更新顏色設定
			qsa('.random-color-btn').forEach(btn => { btn.addEventListener('click', () => { const targetId = btn.dataset.target; if (targetId && settings.hasOwnProperty(targetId)) { const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'); settings[targetId] = randomColor; document.getElementById(targetId).value = randomColor; saveState(); applyAllSettings(); } }); }); // 為所有隨機顏色按鈕新增點擊事件
			qs('#countySelect').addEventListener('change', () => { updateDistrictSelector(qs('#countySelect').value); syncLocationControls(); }); // 監聽縣市選擇器的變更，更新鄉鎮市區選單並同步地點
			qs('#districtSelect').addEventListener('change', syncLocationControls); // 監聽鄉鎮市區選擇器的變更，同步地點
			qs('#weatherLocation').addEventListener('change', e => { const loc = e.target.value.trim(); if(loc) { settings.weatherLocation = loc; setLocationSelectorsFromEnglish(loc); saveState(); updateWeather(); } }); // 監聽隱藏的英文地點輸入框的變更，更新設定和天氣
			qs('#useCurrentLocationBtn').addEventListener('click', () => { if (navigator.geolocation) { updateMarquee('正在定位...', 'weather'); navigator.geolocation.getCurrentPosition( pos => { fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${pos.coords.latitude}&longitude=${pos.coords.longitude}&localityLanguage=en`).then(r => r.json()).then(geo => { const city = geo.locality || geo.city; if (city) { settings.weatherLocation = city; setLocationSelectorsFromEnglish(city); saveState(); updateWeather(); } else updateMarquee(`<span style="color: ${settings.weatherColor};">定位失敗</span>`, 'weather'); }).catch(() => updateMarquee(`<span style="color: ${settings.weatherColor};">定位失敗</span>`, 'weather')); }, () => updateMarquee(`<span style="color: ${settings.weatherColor};">定位失敗，請檢查權限</span>`, 'weather'), { timeout: 10000 } ); } }); // 為 '使用目前位置' 按鈕新增點擊事件，使用地理定位 API 獲取位置
			qs('#restoreDefaultsBtn').onclick = restoreDefaults; qs('#randomColorsBtn').onclick = setRandomColors; // 為 '恢復預設' 和 '隨機顏色' 按鈕設定點擊事件
			document.body.addEventListener('click', e => { // 為 body 新增點擊事件，用於處理非編輯模式下的元件點擊
				if (settings.editMode || state.isDragging) return; // 如果在編輯模式或正在拖曳，則不執行
				const target = e.target; // 獲取點擊的目標元素
				if (target.closest('#weatherMarqueeContainer')) showWeatherForecast(); // 如果點擊的是天氣跑馬燈，顯示天氣預報
				else if (target.closest('.jieqi-holiday-marquee-container')) showDateDetails(new Date()); // 如果點擊的是節氣假日跑馬燈，顯示當天詳細資訊
				else if (target.closest('.lunar-shichen-target')) updateShiChenDetailsView(new Date()); // 如果點擊的是時辰，顯示時辰詳細資訊
				else if (target.closest('.lunar-day-target')) showDateDetails(new Date()); // 如果點擊的是農曆日，顯示當天詳細資訊
				else if (target.closest('.lunar-month-text-target') || target.closest('.gregorian-month-target')) { state.calendarDate = new Date(); generateCalendarPopup(state.calendarDate.getFullYear(), state.calendarDate.getMonth()); qs('#calendarModal').classList.add('is-active'); } // 如果點擊的是月份，顯示月曆
				else if (target.closest('.moon-phase-icon-target')) showMoonPhaseDetails(new Date()); // 如果點擊的是月相，顯示月相詳細資訊
				else if (target.closest('.lunar-year-target')) showZodiacDetails(); // 如果點擊的是農曆年，顯示十二生肖
				else if (target.closest('.gregorian-year-target')) { state.yearlyCalendarDate = new Date(); generateYearCalendar(state.yearlyCalendarDate.getFullYear()); qs('#yearlyCalendarModal').classList.add('is-active'); } // 如果點擊的是陽曆年，顯示年曆
				else if (target.closest('.weekday-target')) { state.weeklyCalendarDate = new Date(); generateWeekCalendar(state.weeklyCalendarDate); qs('#weeklyCalendarModal').classList.add('is-active'); } // 如果點擊的是星期，顯示週曆
				else if (target.closest('.gregorian-day-target')) showDateDetails(new Date()); // 如果點擊的是陽曆日，顯示當天詳細資訊
				else if (target.closest('#analog-calendar-widget .calendar-container')) { state.calendarDate = new Date(); generateCalendarPopup(state.calendarDate.getFullYear(), state.calendarDate.getMonth()); qs('#calendarModal').classList.add('is-active'); } // 如果點擊的是類比日曆，顯示月曆
				else if (target.closest('#clockCenterDot')) updateShiChenDetailsView(new Date()); // 如果點擊的是時鐘中心點，顯示時辰詳細資訊
			});
			qsa('.close-icon').forEach(btn => btn.onclick = () => btn.closest('.modal').classList.remove('is-active')); // 為所有關閉圖示新增點擊事件，用於關閉彈出視窗
			qsa('.modal').forEach(modal => modal.addEventListener('click', e => { if (e.target === modal) modal.classList.remove('is-active'); })); // 為所有彈出視窗新增點擊事件，點擊背景區域可關閉視窗
			qs('#backToWeeklyForecastBtn').onclick = () => { qs('#hourlyWeatherModal').classList.remove('is-active'); qs('#weatherForecastModal').classList.add('is-active'); }; // 為 '返回一週預報' 按鈕設定點擊事件
			qs('#todayCalendarBtn').onclick = () => { state.calendarDate = new Date(); generateCalendarPopup(state.calendarDate.getFullYear(), state.calendarDate.getMonth()); }; // 月曆中的 '今天' 按鈕
			qs('#todayWeeklyBtn').onclick = () => { state.weeklyCalendarDate = new Date(); generateWeekCalendar(state.weeklyCalendarDate); }; // 週曆中的 '本週' 按鈕
			qs('#todayYearlyBtn').onclick = () => { state.yearlyCalendarDate = new Date(); generateYearCalendar(state.yearlyCalendarDate.getFullYear()); }; // 年曆中的 '今年' 按鈕
			qs('#prevMonthBtn').onclick = () => { state.calendarDate.setMonth(state.calendarDate.getMonth() - 1); generateCalendarPopup(state.calendarDate.getFullYear(), state.calendarDate.getMonth()); }; // 月曆的 '上個月' 按鈕
			qs('#nextMonthBtn').onclick = () => { state.calendarDate.setMonth(state.calendarDate.getMonth() + 1); generateCalendarPopup(state.calendarDate.getFullYear(), state.calendarDate.getMonth()); }; // 月曆的 '下個月' 按鈕
			qs('#prevWeekBtn').onclick = () => { state.weeklyCalendarDate.setDate(state.weeklyCalendarDate.getDate() - 7); generateWeekCalendar(state.weeklyCalendarDate); }; // 週曆的 '上一週' 按鈕
			qs('#nextWeekBtn').onclick = () => { state.weeklyCalendarDate.setDate(state.weeklyCalendarDate.getDate() + 7); generateWeekCalendar(state.weeklyCalendarDate); }; // 週曆的 '下一週' 按鈕
			qs('#prevYearBtn').onclick = () => { state.yearlyCalendarDate.setFullYear(state.yearlyCalendarDate.getFullYear() - 1); generateYearCalendar(state.yearlyCalendarDate.getFullYear()); }; // 年曆的 '上一年' 按鈕
			qs('#nextYearBtn').onclick = () => { state.yearlyCalendarDate.setFullYear(state.yearlyCalendarDate.getFullYear() + 1); generateYearCalendar(state.yearlyCalendarDate.getFullYear()); }; // 年曆的 '下一年' 按鈕
			qs('#calendarMonthYear').onclick = () => { const year = parseInt(qs('#calendarMonthYear').dataset.year); qs('#calendarModal').classList.remove('is-active'); state.yearlyCalendarDate.setFullYear(year); generateYearCalendar(year); qs('#yearlyCalendarModal').classList.add('is-active'); }; // 點擊月曆標題的年份，切換到年曆檢視
			qs('#prevShichenBtn').onclick = () => { state.shichenDetailDate.setHours(state.shichenDetailDate.getHours() - 2); updateShiChenDetailsView(state.shichenDetailDate); }; // 時辰詳細資訊的 '上一個時辰' 按鈕
			qs('#nextShichenBtn').onclick = () => { state.shichenDetailDate.setHours(state.shichenDetailDate.getHours() + 2); updateShiChenDetailsView(state.shichenDetailDate); }; // 時辰詳細資訊的 '下一個時辰' 按鈕
			qs('#nowShichenBtn').onclick = () => updateShiChenDetailsView(new Date()); // 時辰詳細資訊的 '當前時辰' 按鈕
			qs('#prevMoonMonthBtn').onclick = () => { state.moonCalendarDate.setMonth(state.moonCalendarDate.getMonth() - 1); generateMoonPhaseCalendar(state.moonCalendarDate.getFullYear(), state.moonCalendarDate.getMonth(), state.moonCalendarDate); }; // 月相日曆的 '上個月' 按鈕
			qs('#nextMoonMonthBtn').onclick = () => { state.moonCalendarDate.setMonth(state.moonCalendarDate.getMonth() + 1); generateMoonPhaseCalendar(state.moonCalendarDate.getFullYear(), state.moonCalendarDate.getMonth(), state.moonCalendarDate); }; // 月相日曆的 '下個月' 按鈕
			qs('#todayMoonCalendarBtn').onclick = () => { const today = new Date(); today.setHours(12,0,0,0); state.moonCalendarDate = today; updateMainMoonPhaseDisplay(today); generateMoonPhaseCalendar(today.getFullYear(), today.getMonth(), today); }; // 月相日曆的 '今天' 按鈕
			qs('#settings-icon').addEventListener('click', () => { qs('#settingsModal').classList.add('is-active'); updateSettingsModalUI(); updateSettingDependencies(); }); // 設定圖示的點擊事件，打開設定視窗
			qs('#edit-mode-icon').addEventListener('click', () => { settings.editMode = !settings.editMode; toggleEditModeState(); saveState(); }); // 編輯模式圖示的點擊事件，切換編輯模式
			qs('#fullscreen-icon').addEventListener('click', () => { if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(err => console.warn(`無法進入全螢幕模式: ${err.message}`)); else if (document.exitFullscreen) document.exitFullscreen(); }); // 全螢幕圖示的點擊事件，切換全螢幕模式
			const handleFullscreen = () => { // 定義處理全螢幕變更的函式
				const isFullscreen = !!document.fullscreenElement; // 檢查當前是否處於全螢幕模式
				const enterIcon = qs('#fullscreen-icon .enter-fullscreen-svg'), exitIcon = qs('#fullscreen-icon .exit-fullscreen-svg'), button = qs('#fullscreen-icon'); // 獲取全螢幕圖示相關元素
				if (enterIcon && exitIcon && button) { // 確保元素都存在
					enterIcon.style.display = isFullscreen ? 'none' : 'block'; // 根據全螢幕狀態顯示或隱藏 '進入全螢幕' 圖示
					exitIcon.style.display = isFullscreen ? 'block' : 'none'; // 根據全螢幕狀態顯示或隱藏 '退出全螢幕' 圖示
					button.title = isFullscreen ? '退出全螢幕' : '全螢幕'; // 更新按鈕的工具提示
				}
				window.dispatchEvent(new Event('resize')); // 觸發 resize 事件以重新計算佈局
			};
			const handleResize = () => { if (constrainPositions()) { applyTransforms(); } }; // 定義處理視窗大小變更的函式，如果需要則限制元件位置並應用變換
			document.addEventListener('fullscreenchange', handleFullscreen); document.addEventListener('webkitfullscreenchange', handleFullscreen); // 監聽全螢幕狀態變更事件
			window.addEventListener('resize', handleResize); // 監聽視窗大小變更事件
			let inactivityTimer; const icons = qsa('.control-icon'); // 定義閒置計時器和獲取所有控制圖示
			const resetIdle = () => { // 定義重置閒置狀態的函式
				icons.forEach(icon => { if (window.getComputedStyle(icon).display !== 'none') setStyle(icon, { opacity: '0.5' }); }); // 將所有可見的圖示透明度設為 0.5
				clearTimeout(inactivityTimer); // 清除之前的計時器
				inactivityTimer = setTimeout(() => icons.forEach(icon => setStyle(icon, { opacity: '0' })), 5000); // 5 秒後將圖示透明度設為 0 (隱藏)
			};
			['mousemove', 'keydown', 'touchstart'].forEach(evt => document.addEventListener(evt, resetIdle)); // 監聽滑鼠移動、鍵盤按下和觸控開始事件來重置閒置計時
			resetIdle(); // 初始呼叫一次以設定初始狀態
			const dragStart = (e) => { // 定義拖曳開始的函式
				if (!settings.editMode) return; // 只有在編輯模式下才生效
				const wrapper = e.target.closest('.widget-wrapper'); // 找到被點擊的元件包裝器
				if (!wrapper) return; // 如果沒找到，則不執行
				e.preventDefault(); // 防止預設行為 (如文字選取)
				state.isDragging = true; state.dragTarget = wrapper.id.replace('-widget', ''); // 設定拖曳狀態和目標元件 ID
				const T = transformState[state.dragTarget]; if (!T) return; // 獲取目標元件的變換狀態，如果不存在則返回
				const event = e.touches ? e.touches[0] : e; // 處理觸控和滑鼠事件的差異
				state.startX = event.clientX; state.startY = event.clientY; // 記錄拖曳開始時的游標位置
				if (e.target.classList.contains('resize-handle-x')) { state.dragType = 'resize-x'; document.body.style.cursor = 'ew-resize'; state.initialWidth = T.width || 92; } // 如果點擊的是水平調整大小的控制點
				else if (e.target.classList.contains('move-handle')) { state.dragType = 'move'; document.body.style.cursor = 'move'; state.initialX = T.x; state.initialY = T.y; } // 如果點擊的是移動的控制點
				else { state.dragType = 'scale'; document.body.style.cursor = 'nwse-resize'; const rect = wrapper.getBoundingClientRect(); const centerX = rect.left + rect.width / 2; const centerY = rect.top + rect.height / 2; state.initialDist = Math.hypot(state.startX - centerX, state.startY - centerY); state.initialScale = T.scale; } // 否則視為縮放操作
				window.addEventListener('mousemove', dragMove); window.addEventListener('touchmove', dragMove, { passive: false }); window.addEventListener('mouseup', dragEnd); window.addEventListener('touchend', dragEnd); // 為 window 新增移動和結束事件的監聽器
			};
			const dragMove = (e) => { // 定義拖曳過程中的函式
				if (!state.isDragging || !state.dragTarget) return; // 如果不在拖曳狀態，則不執行
				e.preventDefault(); // 防止預設行為 (如頁面滾動)
				const T = transformState[state.dragTarget]; const el = qs(`#${state.dragTarget}-widget`); // 獲取目標元件的變換狀態和 DOM 元素
				if (!el || !T) return; // 如果不存在，則返回
				const event = e.touches ? e.touches[0] : e; // 處理觸控和滑鼠事件的差異
				const dx = event.clientX - state.startX; const dy = event.clientY - state.startY; // 計算游標的移動距離
				requestAnimationFrame(() => { // 使用 requestAnimationFrame 來優化渲染
					if (!state.isDragging) return; // 再次檢查是否仍在拖曳
					if (state.dragType === 'move') { // 如果是移動操作
						const handleSize = 40, margin = 10; // 定義控制點大小和邊界
						const minX = -window.innerWidth / 2 + handleSize / 2 + margin, maxX = window.innerWidth / 2 - handleSize / 2 - margin; // 計算 X 軸邊界
						const minY = -window.innerHeight / 2 + handleSize / 2 + margin, maxY = window.innerHeight / 2 - handleSize / 2 - margin; // 計算 Y 軸邊界
						T.x = Math.max(minX, Math.min(maxX, state.initialX + dx)); // 更新 X 座標並限制在邊界內
						T.y = Math.max(minY, Math.min(maxY, state.initialY + dy)); // 更新 Y 座標並限制在邊界內
					}
					else if (state.dragType === 'scale') { const rect = el.getBoundingClientRect(); const centerX = rect.left + rect.width / 2; const centerY = rect.top + rect.height / 2; const currentDist = Math.hypot(event.clientX - centerX, event.clientY - centerY); if (state.initialDist > 0) { const scaleFactor = currentDist / state.initialDist; T.scale = Math.max(0.2, state.initialScale * scaleFactor); } } // 如果是縮放操作，根據游標到中心的距離計算縮放比例
					else if (state.dragType === 'resize-x') { const widthInVw = (dx / window.innerWidth) * 100; T.width = Math.max(20, state.initialWidth + widthInVw); } // 如果是水平調整大小，根據 X 軸移動距離計算新的寬度
					applyTransforms(); // 應用所有元件的變換
				});
			};
			const dragEnd = () => { // 定義拖曳結束的函式
				if (!state.isDragging) return; // 如果不在拖曳狀態，則不執行
				state.isDragging = false; state.dragTarget = null; state.dragType = null; // 重置拖曳相關的狀態
				document.body.style.cursor = 'default'; // 恢復預設的滑鼠指標
				if (constrainPositions()) applyTransforms(); // 再次檢查並限制位置
				saveState(); // 保存目前的元件狀態
				window.removeEventListener('mousemove', dragMove); window.removeEventListener('touchmove', dragMove); window.removeEventListener('mouseup', dragEnd); window.removeEventListener('touchend', dragEnd); // 移除在 window 上新增的事件監聽器
			};
			document.addEventListener('mousedown', dragStart); document.addEventListener('touchstart', dragStart, { passive: false }); // 為 document 新增拖曳開始的事件監聽器
		}
		function initializeApp() { // 定義應用程式的初始化函式
			['movementIntervalMinutes', 'movementIntervalSeconds', 'scanlineIntervalMinutes', 'scanlineIntervalSeconds'].forEach(id => { const sel = document.getElementById(id); if (sel) for (let i = 0; i <= 59; i++) { const opt = document.createElement('option'); opt.value = i; opt.textContent = i; sel.appendChild(opt); } }); // 為設定中的時間間隔下拉選單（分和秒）生成 0-59 的選項
			const countySelect = qs('#countySelect'); // 獲取縣市選擇的下拉選單元素
			for (const county in taiwanLocations) { const opt = document.createElement('option'); opt.value = county; opt.textContent = county; countySelect.appendChild(opt); } // 遍歷台灣地點資料，將縣市名稱加入到下拉選單中
			loadState(); // 載入之前保存的應用程式狀態
			constrainPositions(); // 檢查並限制所有元件的位置，防止載入時超出邊界
			updateSettingsModalUI(); updateSettingDependencies(); initializeTimers(); initializeAnalogClock(); createAnalogCalendar(); // 更新設定介面、初始化計時器、類比時鐘和類比日曆
			applyAllSettings(); applyTransforms(); updateWidgetVisibility(); clearInterval(timers.weather); updateWeather(); // 應用所有設定、變換、更新元件可見性，並立即更新一次天氣
			timers.weather = setInterval(updateWeather, 10 * 60 * 1000); // 設定每 10 分鐘自動更新一次天氣資訊
			initializeEventListeners(); // 初始化所有的事件監聽器
		}
		window.onload = initializeApp; // 當頁面完全載入後，執行應用程式的初始化函式
	</script>
</body>
</html>
